[
  {
    "objectID": "urban-flood-inventory.html",
    "href": "urban-flood-inventory.html",
    "title": "Flood Inventory and Feature Selection",
    "section": "",
    "text": "A synthetic flood inventory is built by sampling flooded points inside FEMA/USVI high-risk zones (FLD_ZONE in {VE, AE, AO, A}) and non-flooded points from the residual safe area, further constrained to elevations greater than 5 m according to the DEM. After removing overlaps, 400 flooded and 400 non-flooded points were retained. Each point carries a binary label (1 = flooded, 0 = non-flooded). The resulting map shows flooded and non-flooded points across the island of St. Thomas. This balanced inventory is then split 70/30 for training and testing the machine-learning flood susceptibility model. For detailed code on how the flood inventory was processed, please refer to this repository.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport numpy as np\nfrom pathlib import Path\nimport geopandas as gpd\n\nimages_dir = Path(\"images\")\nimages_dir.mkdir(exist_ok=True)\n\n# reuse existing boundary/inventory; load boundary if missing\ntry:\n    boundary  # noqa: F821\nexcept NameError:\n    boundary = gpd.read_file(\"data/processed/st_thomas_boundary.geojson\")\n\n# inventory must already exist in memory (with 'label' column)\n# if not, rerun the sampling step that builds pos_pts/neg_pts and concatenates them\nif \"inventory\" not in globals():\n    raise RuntimeError(\"inventory not found; run the sampling step first\")\n\ncmap = plt.cm.viridis\ncolors = cmap(np.linspace(0, 1, 3))\nneg_color, pos_color = colors[0], colors[2]\n\npos_gdf = inventory[inventory[\"label\"] == 1]\nneg_gdf = inventory[inventory[\"label\"] == 0]\n\nfig, ax = plt.subplots(figsize=(8, 10))\nfig.patch.set_alpha(0.0)\nax.set_facecolor(\"none\")\n\nboundary.boundary.plot(ax=ax, color=\"black\", linewidth=1, label=\"Boundary\")\nneg_gdf.plot(ax=ax, color=neg_color, markersize=8, alpha=0.8, label=\"Non-flooded points\")\npos_gdf.plot(ax=ax, color=pos_color, markersize=8, alpha=0.8, label=\"Flooded points\")\n\nax.set_axis_off()\nlegend_patches = [\n    mpatches.Patch(color=neg_color, label=\"Non-flooded points\"),\n    mpatches.Patch(color=pos_color, label=\"Flooded points\"),\n    mpatches.Patch(facecolor=\"none\", edgecolor=\"black\", label=\"Boundary\"),\n]\nax.legend(handles=legend_patches, loc=\"lower left\")\nplt.tight_layout()\n\n\n\n\n\nFigure 1: Flood inventory map of St Thomas",
    "crumbs": [
      "Methods and Analysis",
      "Flood Inventory and Feature Selection"
    ]
  },
  {
    "objectID": "urban-flood-inventory.html#flood-inventory-construction",
    "href": "urban-flood-inventory.html#flood-inventory-construction",
    "title": "Flood Inventory and Feature Selection",
    "section": "",
    "text": "A synthetic flood inventory is built by sampling flooded points inside FEMA/USVI high-risk zones (FLD_ZONE in {VE, AE, AO, A}) and non-flooded points from the residual safe area, further constrained to elevations greater than 5 m according to the DEM. After removing overlaps, 400 flooded and 400 non-flooded points were retained. Each point carries a binary label (1 = flooded, 0 = non-flooded). The resulting map shows flooded and non-flooded points across the island of St. Thomas. This balanced inventory is then split 70/30 for training and testing the machine-learning flood susceptibility model. For detailed code on how the flood inventory was processed, please refer to this repository.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport numpy as np\nfrom pathlib import Path\nimport geopandas as gpd\n\nimages_dir = Path(\"images\")\nimages_dir.mkdir(exist_ok=True)\n\n# reuse existing boundary/inventory; load boundary if missing\ntry:\n    boundary  # noqa: F821\nexcept NameError:\n    boundary = gpd.read_file(\"data/processed/st_thomas_boundary.geojson\")\n\n# inventory must already exist in memory (with 'label' column)\n# if not, rerun the sampling step that builds pos_pts/neg_pts and concatenates them\nif \"inventory\" not in globals():\n    raise RuntimeError(\"inventory not found; run the sampling step first\")\n\ncmap = plt.cm.viridis\ncolors = cmap(np.linspace(0, 1, 3))\nneg_color, pos_color = colors[0], colors[2]\n\npos_gdf = inventory[inventory[\"label\"] == 1]\nneg_gdf = inventory[inventory[\"label\"] == 0]\n\nfig, ax = plt.subplots(figsize=(8, 10))\nfig.patch.set_alpha(0.0)\nax.set_facecolor(\"none\")\n\nboundary.boundary.plot(ax=ax, color=\"black\", linewidth=1, label=\"Boundary\")\nneg_gdf.plot(ax=ax, color=neg_color, markersize=8, alpha=0.8, label=\"Non-flooded points\")\npos_gdf.plot(ax=ax, color=pos_color, markersize=8, alpha=0.8, label=\"Flooded points\")\n\nax.set_axis_off()\nlegend_patches = [\n    mpatches.Patch(color=neg_color, label=\"Non-flooded points\"),\n    mpatches.Patch(color=pos_color, label=\"Flooded points\"),\n    mpatches.Patch(facecolor=\"none\", edgecolor=\"black\", label=\"Boundary\"),\n]\nax.legend(handles=legend_patches, loc=\"lower left\")\nplt.tight_layout()\n\n\n\n\n\nFigure 1: Flood inventory map of St Thomas",
    "crumbs": [
      "Methods and Analysis",
      "Flood Inventory and Feature Selection"
    ]
  },
  {
    "objectID": "urban-flood-inventory.html#feature-selection",
    "href": "urban-flood-inventory.html#feature-selection",
    "title": "Flood Inventory and Feature Selection",
    "section": "Feature Selection",
    "text": "Feature Selection\nTo capture the environmental, hydrologic, and anthropogenic conditions shaping flood susceptibility on St. Thomas, the feature selection process incorporates 14 predictors derived from elevation, terrain, land cover, hazard zones, and proximity indicators. Land cover plays a particularly important role. This land cover dataset includes 13 distinct land cover classes, spanning developed areas (low-, medium-, and high-intensity; and open space), which represent gradations of built environments and impervious surfaces. Natural land cover classes are also well represented, including Forest, Shrubland, and Rangeland, which capture vegetation structure and ecological variation across the island, and additional categories such as water, wetland, cultivated land, barren surfaces, seaside areas, and airport land. Land cover classes were spatially joined to each inventory point using geopandas.sjoin, and one-hot encoded using pandas.get_dummies, allowing categorical surface types to be incorporated into the Random Forest model. These steps ensure that each observation contains a consistent set of hydrologic and land-based predictors representing both natural and built environmental processes. In addition, raster-based variables—such as elevation, slope, and distance to ghuts, were extracted at each sample location using a coordinate, based sampling function (rasterio.sample). The tsunami exposure variable was encoded as a binary indicator by testing whether each point fell within the designated tsunami zone polygon.\nCollectively, these features capture the core mechanisms shaping flood behavior on small tropical islands. Areas closer to ghuts are more vulnerable to channel overflow; lower elevations and flatter terrain accumulate surface water; steeper slopes enhance runoff and reduce ponding; and developed land, with extensive impervious surfaces, tends to exhibit higher flood sensitivity compared to vegetated or permeable surfaces. By encoding these relationships numerically, the resulting predictor matrix provides a comprehensive representation of the physical and anthropogenic drivers of flood susceptibility across St. Thomas.\nTo minimize multicollinearity, Pearson correlation coefficients were computed among all selected predictors. The absolute values of all coefficients remained below 0.8, consistent with prior literature noting that |PCC| &gt; 0.8 may introduce problematic collinearity.\n\n\nCode\nimport os\nfrom pathlib import Path\n\nimages_dir = Path(\"images\")\nimages_dir.mkdir(exist_ok=True)\n\n# ML: Random Forest\nfeature_cols = [c for c in inventory.columns \n                if c not in [\"geometry\", \"label\", \"index_right\",\n                             \"rain_annual_mean\", \"rain_max_month\",\"lc_Rangeland\"]]\nX = inventory[feature_cols].values\ny = inventory[\"label\"].values\n\n# Train-test split\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.3, random_state=42, stratify=y\n)\n\n# Convert training set to DataFrame for correlation analysis\ntrain_df = pd.DataFrame(X_train, columns=feature_cols)\n\n# Plot correlation heatmap WITH numeric values\nplt.figure(figsize=(8, 6))\nsns.heatmap(\n    train_df.corr(),\n    cmap=\"coolwarm\",\n    vmin=-1,\n    vmax=1,\n    annot=True,\n    fmt=\".2f\",\n    annot_kws={\"size\": 8}\n)\nplt.xticks(rotation=45, ha=\"right\")\nplt.yticks(rotation=0)\nplt.show()\n\n\n\n\n\nFigure 2: Pairwise correlation heatmap",
    "crumbs": [
      "Methods and Analysis",
      "Flood Inventory and Feature Selection"
    ]
  },
  {
    "objectID": "shelter-seeking.html",
    "href": "shelter-seeking.html",
    "title": "Shelter Seeking",
    "section": "",
    "text": "A walkable network was built with Pandana by projecting OSM street nodes/edges to the project CRS, marking shelter POIs, and running Pandana shortest-path queries to compute walking distance from each network node to its nearest shelter. These node-level distances were mapped back to buildings via the nearest network node, producing a per-building “walking distance to nearest shelter” attribute, and a Pandana heatmap visualizes shelter accessibility across the island.\nThe walking-distance map shows clear spatial gradients: central shelters are concentrated on the south side of St. Thomas, where nearby buildings have the shortest distances (tens to a few hundred meters), while peripheral areas exceed roughly 2000–3500 m, highlighting accessibility gaps where adding shelter capacity or improving pedestrian connectivity would most reduce isolation.\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nimport geopandas as gpd\n\n# Align CRS\nboundary_3857 = boundary.to_crs(target_crs)\nshelters_3857 = shelters.to_crs(target_crs).copy()\n\n# Fix boundary and build a union\nboundary_union = boundary_3857.buffer(0).unary_union\n\n# Clip nodes to boundary\nnodes_clipped = nodes_gdf_3857[\n    nodes_gdf_3857.geometry.within(boundary_union)\n].copy()\n\ndef plot_walking_distance_to_shelter(\n    nodes_gdf_3857,\n    shelters_3857,\n    column=\"dist_to_shelter_m\",\n    title=\"Walking Distance to Nearest Shelter\"\n):\n    fig, ax = plt.subplots(figsize=(10, 4))\n    divider = make_axes_locatable(ax)\n    cax = divider.append_axes(\"right\", size=\"5%\", pad=0.1)\n\n    # Plot clipped nodes colored by walking distance\n    plot_kwargs = {\"s\": 10, \"alpha\": 0.9, \"cmap\": \"viridis_r\", \"edgecolor\": \"none\"}\n    scatter = nodes_gdf_3857.plot(\n        ax=ax,\n        cax=cax,\n        column=column,\n        legend=True,\n        **plot_kwargs\n    )\n\n    # Add shelters as red stars\n    shelters_3857.plot(ax=ax, color=\"red\", markersize=50, marker=\"*\", label=\"Shelters\")\n\n    # Add boundary\n    boundary_3857.boundary.plot(ax=ax, edgecolor=\"white\", linewidth=1)\n\n    # Formatting\n    fig.patch.set_facecolor(\"#2b005a\")\n    ax.set_facecolor(\"#2b005a\")\n    xmin, ymin, xmax, ymax = boundary_3857.total_bounds\n    ax.set_xlim(xmin, xmax)\n    ax.set_ylim(ymin, ymax)\n    ax.set_axis_off()\n\n    # Legend styling\n    leg = ax.legend()\n    if leg:\n        for txt in leg.get_texts():\n            txt.set_color(\"white\")\n        leg.get_frame().set_facecolor(\"#2b005a\")\n        leg.get_frame().set_edgecolor(\"white\")\n\n    plt.tight_layout()\n    return ax\n\n# Example usage:\nax = plot_walking_distance_to_shelter(\n    nodes_gdf_3857=nodes_clipped,\n    shelters_3857=shelters_3857,\n    column=\"dist_to_shelter_m\"\n)\nplt.show()\n\n\n\n\n\nFigure 3: Distance to Nearest Shelter",
    "crumbs": [
      "Methods and Analysis",
      "Shelter Seeking"
    ]
  },
  {
    "objectID": "shelter-seeking.html#distance-to-nearest-shelter",
    "href": "shelter-seeking.html#distance-to-nearest-shelter",
    "title": "Shelter Seeking",
    "section": "",
    "text": "A walkable network was built with Pandana by projecting OSM street nodes/edges to the project CRS, marking shelter POIs, and running Pandana shortest-path queries to compute walking distance from each network node to its nearest shelter. These node-level distances were mapped back to buildings via the nearest network node, producing a per-building “walking distance to nearest shelter” attribute, and a Pandana heatmap visualizes shelter accessibility across the island.\nThe walking-distance map shows clear spatial gradients: central shelters are concentrated on the south side of St. Thomas, where nearby buildings have the shortest distances (tens to a few hundred meters), while peripheral areas exceed roughly 2000–3500 m, highlighting accessibility gaps where adding shelter capacity or improving pedestrian connectivity would most reduce isolation.\n\n\nCode\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nimport geopandas as gpd\n\n# Align CRS\nboundary_3857 = boundary.to_crs(target_crs)\nshelters_3857 = shelters.to_crs(target_crs).copy()\n\n# Fix boundary and build a union\nboundary_union = boundary_3857.buffer(0).unary_union\n\n# Clip nodes to boundary\nnodes_clipped = nodes_gdf_3857[\n    nodes_gdf_3857.geometry.within(boundary_union)\n].copy()\n\ndef plot_walking_distance_to_shelter(\n    nodes_gdf_3857,\n    shelters_3857,\n    column=\"dist_to_shelter_m\",\n    title=\"Walking Distance to Nearest Shelter\"\n):\n    fig, ax = plt.subplots(figsize=(10, 4))\n    divider = make_axes_locatable(ax)\n    cax = divider.append_axes(\"right\", size=\"5%\", pad=0.1)\n\n    # Plot clipped nodes colored by walking distance\n    plot_kwargs = {\"s\": 10, \"alpha\": 0.9, \"cmap\": \"viridis_r\", \"edgecolor\": \"none\"}\n    scatter = nodes_gdf_3857.plot(\n        ax=ax,\n        cax=cax,\n        column=column,\n        legend=True,\n        **plot_kwargs\n    )\n\n    # Add shelters as red stars\n    shelters_3857.plot(ax=ax, color=\"red\", markersize=50, marker=\"*\", label=\"Shelters\")\n\n    # Add boundary\n    boundary_3857.boundary.plot(ax=ax, edgecolor=\"white\", linewidth=1)\n\n    # Formatting\n    fig.patch.set_facecolor(\"#2b005a\")\n    ax.set_facecolor(\"#2b005a\")\n    xmin, ymin, xmax, ymax = boundary_3857.total_bounds\n    ax.set_xlim(xmin, xmax)\n    ax.set_ylim(ymin, ymax)\n    ax.set_axis_off()\n\n    # Legend styling\n    leg = ax.legend()\n    if leg:\n        for txt in leg.get_texts():\n            txt.set_color(\"white\")\n        leg.get_frame().set_facecolor(\"#2b005a\")\n        leg.get_frame().set_edgecolor(\"white\")\n\n    plt.tight_layout()\n    return ax\n\n# Example usage:\nax = plot_walking_distance_to_shelter(\n    nodes_gdf_3857=nodes_clipped,\n    shelters_3857=shelters_3857,\n    column=\"dist_to_shelter_m\"\n)\nplt.show()\n\n\n\n\n\nFigure 3: Distance to Nearest Shelter",
    "crumbs": [
      "Methods and Analysis",
      "Shelter Seeking"
    ]
  },
  {
    "objectID": "notebook2.html",
    "href": "notebook2.html",
    "title": "Explore_Floodrisk",
    "section": "",
    "text": "!pip install xlrd\n\nimport numpy as np\nimport pandas as pd\nimport geopandas as gpd\nfrom pathlib import Path\nfrom shapely.geometry import Point\nfrom shapely.ops import unary_union\nimport rasterio\nfrom rasterio.mask import mask\nfrom rasterio.features import rasterize\nfrom rasterio.transform import from_origin\nfrom scipy.ndimage import distance_transform_edt\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import (\n    accuracy_score,\n    roc_auc_score,\n    roc_curve,\n    classification_report,\n)\n\nnp.random.seed(42)\npd.options.display.max_columns = 200\n\n# Paths\ndata_dir = Path(\"data\")\nprocessed = data_dir / \"processed\"\n\n# Vectors \nboundary = gpd.read_file(processed / \"st_thomas_boundary.geojson\")\nflood_zone = gpd.read_file(processed / \"flood_zone_st_thomas_3857.gpkg\")\ntsunami_zone = gpd.read_file(processed / \"tsunami_st_thomas_3857.gpkg\")\nghuts = gpd.read_file(processed / \"ghuts_st_thomas_3857.gpkg\")\nlandcover = gpd.read_file(processed / \"landcover_st_thomas_3857.gpkg\")\nbuildings = gpd.read_file(processed / \"buildings_st_thomas_3857.gpkg\")\n\n# Rasters \ndem_path = processed / \"dem_st_thomas_3857.tif\"\nslope_path = processed / \"slope_degrees_3857.tif\"\nghut_dist_raster = processed / \"ghut_distance_m_3857.tif\" \n\ntarget_crs = \"EPSG:3857\"\nfor gdf in [boundary, flood_zone, tsunami_zone, ghuts, landcover, buildings]:\n    if gdf.crs != target_crs:\n        gdf.to_crs(target_crs, inplace=True)\n\nRequirement already satisfied: xlrd in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (2.0.2)\n\n\n\n# Flood inventory: positive/negative samples\nhigh_risk_codes = [\"VE\", \"AE\",\"AO\",\"A\"]\nflood_field = \"FLD_ZONE\"  \nhigh_risk = flood_zone[flood_zone[flood_field].isin(high_risk_codes)].copy()\nhigh_risk_geom = high_risk.intersection(boundary.unary_union)\n\ndef sample_points_in_polygon(gdf, n_points):\n    polys = gdf.geometry.values\n    xmin, ymin, xmax, ymax = unary_union(polys).bounds\n    pts = []\n    while len(pts) &lt; n_points:\n        x = np.random.uniform(xmin, xmax)\n        y = np.random.uniform(ymin, ymax)\n        p = Point(x, y)\n        if any(poly.contains(p) for poly in polys):\n            pts.append(p)\n    return gpd.GeoDataFrame(geometry=pts, crs=gdf.crs)\n\nn_pos = 400\npos_pts = sample_points_in_polygon(high_risk, n_pos)\npos_pts[\"label\"] = 1\n\n# Safe area = boundary - flood zone\nsafe_area = boundary.overlay(\n    flood_zone,\n    how=\"difference\",\n    keep_geom_type=True \n)\n\ndef sample_points_in_safe_area(gdf, n_points, min_elev=5.0):\n    union = unary_union(gdf.geometry.values)\n    xmin, ymin, xmax, ymax = union.bounds\n    pts = []\n    with rasterio.open(dem_path) as src:\n        for _ in range(n_points * 10):  # safeguard\n            if len(pts) &gt;= n_points:\n                break\n            x = np.random.uniform(xmin, xmax)\n            y = np.random.uniform(ymin, ymax)\n            p = Point(x, y)\n            if union.contains(p):\n                z = list(src.sample([(x, y)]))[0][0]\n                if z &gt; min_elev:\n                    pts.append(p)\n    return gpd.GeoDataFrame(geometry=pts, crs=gdf.crs)\n\nn_neg = n_pos\nneg_pts = sample_points_in_safe_area(safe_area, n_neg, min_elev=5.0)\nneg_pts[\"label\"] = 0\n\ninventory = pd.concat([pos_pts, neg_pts], ignore_index=True)\n\n\nprint(\"Inventory size:\", inventory.shape)\n\nInventory size: (800, 2)\n\n\n\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport numpy as np\nfrom pathlib import Path\nimport geopandas as gpd\n\nimages_dir = Path(\"images\")\nimages_dir.mkdir(exist_ok=True)\n\n# reuse existing boundary/inventory; load boundary if missing\ntry:\n    boundary  # noqa: F821\nexcept NameError:\n    boundary = gpd.read_file(\"data/processed/st_thomas_boundary.geojson\")\n\n# inventory must already exist in memory (with 'label' column)\n# if not, rerun the sampling step that builds pos_pts/neg_pts and concatenates them\nif \"inventory\" not in globals():\n    raise RuntimeError(\"inventory not found; run the sampling step first\")\n\ncmap = plt.cm.viridis\ncolors = cmap(np.linspace(0, 1, 3))\nneg_color, pos_color = colors[0], colors[2]\n\npos_gdf = inventory[inventory[\"label\"] == 1]\nneg_gdf = inventory[inventory[\"label\"] == 0]\n\nfig, ax = plt.subplots(figsize=(8, 10))\nfig.patch.set_alpha(0.0)\nax.set_facecolor(\"none\")\n\nboundary.boundary.plot(ax=ax, color=\"black\", linewidth=1, label=\"Boundary\")\nneg_gdf.plot(ax=ax, color=neg_color, markersize=8, alpha=0.8, label=\"Non-flooded points\")\npos_gdf.plot(ax=ax, color=pos_color, markersize=8, alpha=0.8, label=\"Flooded points\")\n\nax.set_axis_off()\nlegend_patches = [\n    mpatches.Patch(color=neg_color, label=\"Non-flooded points\"),\n    mpatches.Patch(color=pos_color, label=\"Flooded points\"),\n    mpatches.Patch(facecolor=\"none\", edgecolor=\"black\", label=\"Boundary\"),\n]\nax.legend(handles=legend_patches, loc=\"lower left\")\n\nplt.tight_layout()\nout_path = images_dir / \"inventory_points.png\"\nplt.savefig(out_path, dpi=300, bbox_inches=\"tight\", transparent=True)\nprint(f\"Saved plot to {out_path}\")\n\nSaved plot to images\\inventory_points.png\n\n\n\n\n\n\n\n\n\n\n# Feature extraction helpers\ndef sample_raster_values(points_gdf, raster_path, col_name):\n    with rasterio.open(raster_path) as src:\n        coords = [(geom.x, geom.y) for geom in points_gdf.geometry]\n        values = [val[0] for val in src.sample(coords)]\n    points_gdf[col_name] = values\n    return points_gdf\n\n# DEM & slope\ninventory = sample_raster_values(inventory, dem_path, \"elev\")\ninventory = sample_raster_values(inventory, slope_path, \"slope\")\n\n# Tsunami zone flag\ninventory[\"in_tsunami\"] = inventory.geometry.apply(\n    lambda p: tsunami_zone.contains(p).any()\n).astype(int)\n\n# Ghut distance\nuse_raster_dist = True\nif use_raster_dist:\n    inventory = sample_raster_values(inventory, ghut_dist_raster, \"dist_ghut\")\nelse:\n    inventory[\"dist_ghut\"] = inventory.geometry.apply(lambda p: ghuts.distance(p).min())\n\n# Land cover\nlc_field = \"class\" \nlandcover = landcover.rename(columns={lc_field: \"land_class\"})\ninventory = gpd.sjoin(inventory, landcover[[\"land_class\", \"geometry\"]], how=\"left\", predicate=\"within\")\ninventory = pd.get_dummies(inventory, columns=[\"land_class\"], prefix=\"lc\")\n\n\nimport os\nfrom pathlib import Path\n\nimages_dir = Path(\"images\")\nimages_dir.mkdir(exist_ok=True)\n\n# ML: Random Forest\nfeature_cols = [c for c in inventory.columns \n                if c not in [\"geometry\", \"label\", \"index_right\",\n                             \"rain_annual_mean\", \"rain_max_month\",\"lc_Rangeland\"]]\nX = inventory[feature_cols].values\ny = inventory[\"label\"].values\n\n# Train-test split\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.3, random_state=42, stratify=y\n)\n\n# Convert training set to DataFrame for correlation analysis\ntrain_df = pd.DataFrame(X_train, columns=feature_cols)\n\n# Plot correlation heatmap WITH numeric values\nplt.figure(figsize=(12, 10))\nsns.heatmap(\n    train_df.corr(),\n    cmap=\"coolwarm\",\n    vmin=-1,\n    vmax=1,\n    annot=True,\n    fmt=\".2f\",\n    annot_kws={\"size\": 8}\n)\nplt.xticks(rotation=45, ha=\"right\")\nplt.yticks(rotation=0)\nplt.tight_layout()\n\nout_path = images_dir / \"correlation_heatmap.png\"\nplt.savefig(out_path, dpi=300, bbox_inches=\"tight\")\nprint(f\"Saved plot to {out_path}\")\n\nplt.show()\n\nSaved plot to images\\correlation_heatmap.png\n\n\n\n\n\n\n\n\n\n\nrf_pipe = make_pipeline(\n    StandardScaler(),\n    RandomForestClassifier(\n        n_estimators=100,\n        max_depth=10,\n        min_samples_split=5,\n        min_samples_leaf=3,\n        random_state=42,\n        class_weight=\"balanced\",\n    ),\n)\nrf_pipe.fit(X_train, y_train)\nprint(\"Train acc:\", rf_pipe.score(X_train, y_train))\nprint(\"Test acc:\", rf_pipe.score(X_test, y_test))\n\nscores = cross_val_score(rf_pipe, X_train, y_train, cv=5, scoring=\"roc_auc\")\nprint(\"CV AUC mean:\", scores.mean(), \"std:\", scores.std())\n\npipe = make_pipeline(\n    StandardScaler(),\n    RandomForestClassifier(random_state=42, class_weight=\"balanced\")\n)\nparam_grid = {\n    \"randomforestclassifier__n_estimators\": [50, 75, 100, 150],\n    \"randomforestclassifier__max_depth\": [8, 10, 12, None],\n    \"randomforestclassifier__min_samples_split\": [2, 5, 10],\n    \"randomforestclassifier__min_samples_leaf\": [1, 3, 5],\n}\ngrid = GridSearchCV(pipe, param_grid, cv=5, scoring=\"roc_auc\", verbose=1, n_jobs=-1)\ngrid.fit(X_train, y_train)\nbest_model = grid.best_estimator_\nprint(\"Best params:\", grid.best_params_)\nprint(\"Best CV AUC:\", grid.best_score_)\n\nTrain acc: 0.9196428571428571\nTest acc: 0.85\nCV AUC mean: 0.9424107142857142 std: 0.022300099138684734\nFitting 5 folds for each of 144 candidates, totalling 720 fits\nBest params: {'randomforestclassifier__max_depth': 8, 'randomforestclassifier__min_samples_leaf': 1, 'randomforestclassifier__min_samples_split': 5, 'randomforestclassifier__n_estimators': 150}\nBest CV AUC: 0.9459183673469388\n\n\n\ny_pred = best_model.predict(X_test)\ny_proba = best_model.predict_proba(X_test)[:, 1]\nprint(\"Accuracy:\", accuracy_score(y_test, y_pred))\nprint(\"ROC-AUC:\", roc_auc_score(y_test, y_proba))\nprint(classification_report(y_test, y_pred))\n\nfpr, tpr, thr = roc_curve(y_test, y_proba)\nplt.figure(figsize=(6, 5))\nplt.plot(fpr, tpr, label=f\"AUC = {roc_auc_score(y_test, y_proba):.3f}\")\nplt.plot([0, 1], [0, 1], \"k--\")\nplt.xlabel(\"False Positive Rate\")\nplt.ylabel(\"True Positive Rate\")\nplt.legend()\nplt.tight_layout()\nout_path = images_dir / \"roc.png\"\nplt.savefig(out_path, dpi=300, bbox_inches=\"tight\", transparent=True)\nprint(f\"Saved plot to {out_path}\")\n\nAccuracy: 0.85\nROC-AUC: 0.9396527777777778\n              precision    recall  f1-score   support\n\n           0       0.83      0.88      0.85       120\n           1       0.87      0.82      0.85       120\n\n    accuracy                           0.85       240\n   macro avg       0.85      0.85      0.85       240\nweighted avg       0.85      0.85      0.85       240\n\nSaved plot to images\\roc.png\n\n\n\n\n\n\n\n\n\n\nrf_model = best_model.named_steps[\"randomforestclassifier\"]\nimportance = pd.DataFrame({\n    \"Feature\": feature_cols,\n    \"Importance\": rf_model.feature_importances_\n}).sort_values(\"Importance\", ascending=False)\n\ndisplay(importance.head(15))\n\n# Create chart\nimportance = pd.DataFrame({\n    \"Feature\": feature_cols,\n    \"Importance\": rf_model.feature_importances_\n}).sort_values(\"Importance\", ascending=False)\n\nax = importance.sort_values(\"Importance\", ascending=True).plot.barh(\n    x=\"Feature\",\n    y=\"Importance\",\n    figsize=(6, 8),\n    legend=False  # no legend by default\n)\n\n# Increase font sizes\nax.set_xlabel(\"Importance\", fontsize=12)\nax.set_ylabel(\"Feature\", fontsize=12)\nax.tick_params(axis=\"both\", labelsize=11)\n\n# If you do need a legend (e.g., single patch), add it and set fontsize:\n# ax.legend(fontsize=12)\n\nplt.tight_layout()\nout_path = images_dir / \"feature_importance.png\"\nplt.savefig(out_path, dpi=300, bbox_inches=\"tight\", transparent=True)\nprint(f\"Saved plot to {out_path}\")\n\n\n\n\n\n\n\n\nFeature\nImportance\n\n\n\n\n0\nelev\n0.409406\n\n\n1\nslope\n0.193573\n\n\n3\ndist_ghut\n0.190259\n\n\n2\nin_tsunami\n0.138606\n\n\n10\nlc_Forest\n0.026211\n\n\n7\nlc_Developed Low Intensity\n0.006549\n\n\n13\nlc_Wetland\n0.006090\n\n\n8\nlc_Developed Medium Intensity\n0.005824\n\n\n4\nlc_Airport\n0.005724\n\n\n6\nlc_Developed High Intensity\n0.005118\n\n\n9\nlc_Developed open space\n0.004884\n\n\n11\nlc_Shrub\n0.003651\n\n\n5\nlc_Barren\n0.003629\n\n\n12\nlc_Water\n0.000477\n\n\n\n\n\n\n\nSaved plot to images\\feature_importance.png\n\n\n\n\n\n\n\n\n\n\n# Predict to grid and write GeoTIFF (rain fields removed)\nres = 50  # meters\nminx, miny, maxx, maxy = boundary.total_bounds\nxs = np.arange(minx, maxx, res)\nys = np.arange(miny, maxy, res)\n\ngrid_pts = []\nfor x in xs:\n    for y in ys:\n        p = Point(x + res/2, y + res/2)\n        if boundary.geometry.unary_union.contains(p):\n            grid_pts.append(p)\n\ngrid = gpd.GeoDataFrame(geometry=grid_pts, crs=boundary.crs)\nprint(\"Grid points:\", len(grid))\n\ngrid = sample_raster_values(grid, dem_path, \"elev\")\ngrid = sample_raster_values(grid, slope_path, \"slope\")\n\nif use_raster_dist:\n    grid = sample_raster_values(grid, ghut_dist_raster, \"dist_ghut\")\nelse:\n    grid[\"dist_ghut\"] = grid.geometry.apply(lambda p: ghuts.distance(p).min())\n\ngrid = gpd.sjoin(grid, landcover[[\"land_class\", \"geometry\"]], how=\"left\", predicate=\"within\")\ngrid = pd.get_dummies(grid, columns=[\"land_class\"], prefix=\"lc\")\n\n# Drop rain fields entirely\n\ngrid[\"in_tsunami\"] = grid.geometry.apply(\n    lambda p: tsunami_zone.contains(p).any()\n).astype(int)\n\n# Ensure all feature columns are present\nfor c in feature_cols:\n    if c not in grid.columns and c not in [\"geometry\"]:\n        grid[c] = 0\n\nX_grid = grid[feature_cols].values\ngrid[\"suscept_prob\"] = best_model.predict_proba(X_grid)[:, 1]\n\nn_cols = len(xs)\nn_rows = len(ys)\ntransform = from_origin(minx, maxy, res, res)\nsuscept_arr = np.full((n_rows, n_cols), np.nan, dtype=\"float32\")\n\nfor idx, geom in enumerate(grid.geometry):\n    x, y = geom.x, geom.y\n    col = int((x - minx) // res)\n    row = int((maxy - y) // res)\n    suscept_arr[row, col] = grid.iloc[idx][\"suscept_prob\"]\n\nout_path = processed / \"st_thomas_flood_susceptibility.tif\"\nwith rasterio.open(\n    out_path,\n    \"w\",\n    driver=\"GTiff\",\n    height=n_rows,\n    width=n_cols,\n    count=1,\n    dtype=\"float32\",\n    crs=boundary.crs,\n    transform=transform,\n    nodata=np.nan,\n) as dst:\n    dst.write(suscept_arr, 1)\n\nprint(\"Saved susceptibility raster:\", out_path)\n\n# Preview susceptibility raster\nvalid = np.count_nonzero(~np.isnan(suscept_arr))\nprint(\"Non-nan cells:\", valid)\n\nsuscept_masked = np.ma.masked_invalid(suscept_arr)\n\n# Plot\nfig, ax = plt.subplots(figsize=(8, 6))\nimg = ax.imshow(\n    suscept_masked,\n    extent=(minx, maxx, miny, maxy),\n    origin=\"upper\",\n    cmap=\"viridis_r\",\n    vmin=0,\n    vmax=1,\n    interpolation=\"nearest\",\n)\nboundary.boundary.plot(ax=ax, color=\"red\", linewidth=1)\nax.set_title(\"Flood Susceptibility (probability)\")\nax.set_axis_off()\nplt.colorbar(img, ax=ax, shrink=0.7)\nplt.show()\n\nGrid points: 31862\nSaved susceptibility raster: data\\processed\\st_thomas_flood_susceptibility.tif\nNon-nan cells: 31862\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Mask NaNs\nsuscept_masked = np.ma.masked_invalid(suscept_arr)\n\nfig, ax = plt.subplots(figsize=(10, 4))\n\n# Dark purple background\nfig.patch.set_facecolor(\"#2b005a\")\nax.set_facecolor(\"#2b005a\")\n\nimg = ax.imshow(\n    suscept_masked,\n    extent=(minx, maxx, miny, maxy),\n    origin=\"upper\",\n    cmap=\"viridis\",\n    vmin=0,\n    vmax=1,\n    interpolation=\"nearest\",\n)\n\n# Optional boundary overlay\nboundary.boundary.plot(ax=ax, color=\"white\", linewidth=1)\n\n# Horizontal colorbar inset (bottom-left)\ncax = ax.inset_axes([0.05, 0.08, 0.25, 0.06])  # [x, y, width, height] in axis fraction\ncbar = fig.colorbar(img, cax=cax, orientation=\"horizontal\")\ncbar.ax.set_title(\"Susceptibility Index\", fontsize=9, pad=4, color=\"white\")\ncbar.outline.set_linewidth(0)\ncbar.ax.tick_params(size=0)\ncbar.ax.xaxis.set_tick_params(pad=4, colors=\"white\")\n\nax.set_axis_off()\nplt.tight_layout()\nout_path = images_dir / \"flood_susceptibility.png\"\nplt.savefig(out_path, dpi=300, bbox_inches=\"tight\")\nprint(f\"Saved plot to {out_path}\")\n\nSaved plot to images\\flood_susceptibility.png\n\n\n\n\n\n\n\n\n\n\n!pip install rasterio\n!pip install rasterstats\n!pip install hvplot\n!pip install folium matplotlib mapclassify\n\nimport hvplot.pandas  # registers .hvplot accessor on DataFrame / GeoDataFrame\nimport holoviews as hv\nhv.extension(\"bokeh\")  # or \"bokeh\", \"plotly\" depending on what you use\n\nimport geopandas as gpd\nimport pandas as pd\nimport numpy as np\nfrom pathlib import Path\nfrom shapely import make_valid\nimport rasterio\nfrom rasterstats import zonal_stats  # ensure installed\nimport hvplot.pandas  # for interactive maps \n\nRequirement already satisfied: rasterio in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (1.3.8)\nRequirement already satisfied: affine in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (2.4.0)\nRequirement already satisfied: attrs in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (25.3.0)\nRequirement already satisfied: certifi in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (2025.11.12)\nRequirement already satisfied: click&gt;=4.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (8.2.1)\nRequirement already satisfied: cligj&gt;=0.5 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (0.7.2)\nRequirement already satisfied: numpy&gt;=1.18 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (1.24.4)\nRequirement already satisfied: snuggs&gt;=1.4.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (1.4.7)\nRequirement already satisfied: click-plugins in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (1.1.1.2)\nRequirement already satisfied: setuptools in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (80.9.0)\nRequirement already satisfied: colorama in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from click&gt;=4.0-&gt;rasterio) (0.4.6)\nRequirement already satisfied: pyparsing&gt;=2.1.6 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from snuggs&gt;=1.4.1-&gt;rasterio) (3.0.9)\nRequirement already satisfied: rasterstats in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (0.19.0)\nRequirement already satisfied: affine in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterstats) (2.4.0)\nRequirement already satisfied: click&gt;7.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterstats) (8.2.1)\nRequirement already satisfied: cligj&gt;=0.4 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterstats) (0.7.2)\nRequirement already satisfied: fiona in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterstats) (1.9.4)\nRequirement already satisfied: numpy&gt;=1.9 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterstats) (1.24.4)\nRequirement already satisfied: rasterio&gt;=1.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterstats) (1.3.8)\nRequirement already satisfied: simplejson in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterstats) (3.20.1)\nRequirement already satisfied: shapely in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterstats) (2.0.1)\nRequirement already satisfied: colorama in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from click&gt;7.1-&gt;rasterstats) (0.4.6)\nRequirement already satisfied: attrs in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio&gt;=1.0-&gt;rasterstats) (25.3.0)\nRequirement already satisfied: certifi in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio&gt;=1.0-&gt;rasterstats) (2025.11.12)\nRequirement already satisfied: snuggs&gt;=1.4.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio&gt;=1.0-&gt;rasterstats) (1.4.7)\nRequirement already satisfied: click-plugins in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio&gt;=1.0-&gt;rasterstats) (1.1.1.2)\nRequirement already satisfied: setuptools in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio&gt;=1.0-&gt;rasterstats) (80.9.0)\nRequirement already satisfied: six in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from fiona-&gt;rasterstats) (1.17.0)\nRequirement already satisfied: pyparsing&gt;=2.1.6 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from snuggs&gt;=1.4.1-&gt;rasterio&gt;=1.0-&gt;rasterstats) (3.0.9)\nRequirement already satisfied: hvplot in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (0.8.3)\nRequirement already satisfied: bokeh&gt;=1.0.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from hvplot) (3.2.1)\nRequirement already satisfied: colorcet&gt;=2 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from hvplot) (3.1.0)\nRequirement already satisfied: holoviews&gt;=1.11.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from hvplot) (1.17.0)\nRequirement already satisfied: pandas in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from hvplot) (1.5.3)\nRequirement already satisfied: numpy&gt;=1.15 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from hvplot) (1.24.4)\nRequirement already satisfied: packaging in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from hvplot) (25.0)\nRequirement already satisfied: panel&gt;=0.11.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from hvplot) (1.2.1)\nRequirement already satisfied: param&gt;=1.9.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from hvplot) (1.13.0)\nRequirement already satisfied: Jinja2&gt;=2.9 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from bokeh&gt;=1.0.0-&gt;hvplot) (3.1.6)\nRequirement already satisfied: contourpy&gt;=1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from bokeh&gt;=1.0.0-&gt;hvplot) (1.3.2)\nRequirement already satisfied: pillow&gt;=7.1.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from bokeh&gt;=1.0.0-&gt;hvplot) (10.0.0)\nRequirement already satisfied: PyYAML&gt;=3.10 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from bokeh&gt;=1.0.0-&gt;hvplot) (6.0.2)\nRequirement already satisfied: tornado&gt;=5.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from bokeh&gt;=1.0.0-&gt;hvplot) (6.5.2)\nRequirement already satisfied: xyzservices&gt;=2021.09.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from bokeh&gt;=1.0.0-&gt;hvplot) (2025.4.0)\nRequirement already satisfied: pyviz-comms&gt;=0.7.4 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from holoviews&gt;=1.11.0-&gt;hvplot) (2.3.2)\nRequirement already satisfied: python-dateutil&gt;=2.8.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from pandas-&gt;hvplot) (2.9.0.post0)\nRequirement already satisfied: pytz&gt;=2020.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from pandas-&gt;hvplot) (2025.2)\nRequirement already satisfied: markdown in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from panel&gt;=0.11.0-&gt;hvplot) (3.9)\nRequirement already satisfied: markdown-it-py in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from panel&gt;=0.11.0-&gt;hvplot) (4.0.0)\nRequirement already satisfied: linkify-it-py in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from panel&gt;=0.11.0-&gt;hvplot) (2.0.3)\nRequirement already satisfied: mdit-py-plugins in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from panel&gt;=0.11.0-&gt;hvplot) (0.5.0)\nRequirement already satisfied: requests in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from panel&gt;=0.11.0-&gt;hvplot) (2.31.0)\nRequirement already satisfied: tqdm&gt;=4.48.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from panel&gt;=0.11.0-&gt;hvplot) (4.65.0)\nRequirement already satisfied: bleach in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from panel&gt;=0.11.0-&gt;hvplot) (6.2.0)\nRequirement already satisfied: typing-extensions in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from panel&gt;=0.11.0-&gt;hvplot) (4.15.0)\nRequirement already satisfied: MarkupSafe&gt;=2.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from Jinja2&gt;=2.9-&gt;bokeh&gt;=1.0.0-&gt;hvplot) (3.0.2)\nRequirement already satisfied: six&gt;=1.5 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from python-dateutil&gt;=2.8.1-&gt;pandas-&gt;hvplot) (1.17.0)\nRequirement already satisfied: colorama in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from tqdm&gt;=4.48.0-&gt;panel&gt;=0.11.0-&gt;hvplot) (0.4.6)\nRequirement already satisfied: webencodings in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from bleach-&gt;panel&gt;=0.11.0-&gt;hvplot) (0.5.1)\nRequirement already satisfied: uc-micro-py in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from linkify-it-py-&gt;panel&gt;=0.11.0-&gt;hvplot) (1.0.3)\nRequirement already satisfied: mdurl~=0.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from markdown-it-py-&gt;panel&gt;=0.11.0-&gt;hvplot) (0.1.2)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests-&gt;panel&gt;=0.11.0-&gt;hvplot) (3.4.3)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests-&gt;panel&gt;=0.11.0-&gt;hvplot) (3.10)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests-&gt;panel&gt;=0.11.0-&gt;hvplot) (1.26.19)\nRequirement already satisfied: certifi&gt;=2017.4.17 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests-&gt;panel&gt;=0.11.0-&gt;hvplot) (2025.11.12)\nRequirement already satisfied: folium in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (0.14.0)\nRequirement already satisfied: matplotlib in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (3.7.2)\nRequirement already satisfied: mapclassify in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (2.5.0)\nRequirement already satisfied: branca&gt;=0.6.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from folium) (0.8.1)\nRequirement already satisfied: jinja2&gt;=2.9 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from folium) (3.1.6)\nRequirement already satisfied: numpy in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from folium) (1.24.4)\nRequirement already satisfied: requests in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from folium) (2.31.0)\nRequirement already satisfied: contourpy&gt;=1.0.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from matplotlib) (1.3.2)\nRequirement already satisfied: cycler&gt;=0.10 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from matplotlib) (0.12.1)\nRequirement already satisfied: fonttools&gt;=4.22.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from matplotlib) (4.59.2)\nRequirement already satisfied: kiwisolver&gt;=1.0.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from matplotlib) (1.4.9)\nRequirement already satisfied: packaging&gt;=20.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from matplotlib) (25.0)\nRequirement already satisfied: pillow&gt;=6.2.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from matplotlib) (10.0.0)\nRequirement already satisfied: pyparsing&lt;3.1,&gt;=2.3.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from matplotlib) (3.0.9)\nRequirement already satisfied: python-dateutil&gt;=2.7 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from matplotlib) (2.9.0.post0)\nRequirement already satisfied: scipy&gt;=1.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from mapclassify) (1.15.2)\nRequirement already satisfied: scikit-learn in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from mapclassify) (1.3.0)\nRequirement already satisfied: pandas&gt;=1.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from mapclassify) (1.5.3)\nRequirement already satisfied: networkx in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from mapclassify) (3.1)\nRequirement already satisfied: MarkupSafe&gt;=2.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from jinja2&gt;=2.9-&gt;folium) (3.0.2)\nRequirement already satisfied: pytz&gt;=2020.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from pandas&gt;=1.0-&gt;mapclassify) (2025.2)\nRequirement already satisfied: six&gt;=1.5 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from python-dateutil&gt;=2.7-&gt;matplotlib) (1.17.0)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests-&gt;folium) (3.4.3)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests-&gt;folium) (3.10)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests-&gt;folium) (1.26.19)\nRequirement already satisfied: certifi&gt;=2017.4.17 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests-&gt;folium) (2025.11.12)\nRequirement already satisfied: joblib&gt;=1.1.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from scikit-learn-&gt;mapclassify) (1.5.2)\nRequirement already satisfied: threadpoolctl&gt;=2.0.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from scikit-learn-&gt;mapclassify) (3.6.0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Paths and base settings\ndata_dir = Path(\"data\")\nprocessed = data_dir / \"processed\"\n\nbuildings_path = processed / \"buildings_st_thomas_3857.gpkg\"\nparcels_path   = processed / \"parcel_value_st_thomas_3857.gpkg\"\nsuscept_raster = processed / \"st_thomas_flood_susceptibility.tif\"\n\nboundary = gpd.read_file(processed / \"st_thomas_boundary.geojson\")\ntarget_crs = \"EPSG:3857\"\n\n# Load and clean vector data\nbld = gpd.read_file(buildings_path).to_crs(target_crs)\nparcels = gpd.read_file(parcels_path).to_crs(target_crs)\n\n# Ensure valid geometries and remove empty ones\nbld[\"geometry\"] = bld.geometry.apply(make_valid)\nparcels[\"geometry\"] = parcels.geometry.apply(make_valid)\nbld = bld[~bld.geometry.is_empty]\nparcels = parcels[~parcels.geometry.is_empty]\n\n\n# Select residential parcels by zoning code\nres_codes = [\"R-1\", \"R-2\", \"R-3\", \"R-4\", \"R-5\"]\nparcels_res = parcels[parcels[\"DPNR_ZONE\"].isin(res_codes)].copy()\n\n# Ensure land value field is numeric\nparcels_res[\"Land_Value\"] = pd.to_numeric(parcels_res[\"Land_Value\"], errors=\"coerce\")\n\n# Compute parcel area (m²) and land value per m²\nparcels_res[\"parcel_area_m2\"] = parcels_res.geometry.area  # geometry is parcel footprint after sjoin_nearest\nparcels_res[\"land_value_per_m2\"] = parcels_res[\"Land_Value\"] / parcels_res[\"parcel_area_m2\"]\n\n# Spatial join: attach zoning + land value to buildings\nbld_res = gpd.sjoin(\n    bld,\n    parcels_res[[\"DPNR_ZONE\", \"Land_Value\", \"geometry\",\"land_value_per_m2\"]],\n    how=\"inner\",\n    predicate=\"intersects\",\n)\n\n# Remove duplicate footprints caused by intersecting multiple parcels\nbld_res = (\n    bld_res\n    .drop(columns=[\"index_right\"])\n    .drop_duplicates(subset=\"geometry\")\n    .reset_index(drop=True)\n)\n\nprint(\"Residential buildings:\", len(bld_res))\n\n# Compute zonal statistics: median flood susceptibility per building\nwith rasterio.open(suscept_raster) as src:\n    transform = src.transform\n    nodata = src.nodata\n\nstats = zonal_stats(\n    bld_res,\n    suscept_raster,\n    stats=[\"median\"],\n    affine=transform,\n    nodata=nodata,\n    all_touched=True,\n)\n\nbld_res[\"median_suscept\"] = [s[\"median\"] for s in stats]\n\n# Classification bins/labels (0–1 range)\nbins = [0, 0.2, 0.4, 0.6, 0.8, 1.0]\nlabels = [\"Very Low\", \"Low\", \"Moderate\", \"High\", \"Very High\"]\n\n# Assign class\nbld_res[\"suscept_class\"] = pd.cut(\n    bld_res[\"median_suscept\"],\n    bins=bins,\n    labels=labels,\n    include_lowest=True\n)\n\n# Remove buildings that fall in raster NoData regions\nbld_res = bld_res.dropna(subset=[\"median_suscept\"])\nbld_res.head()\n\nResidential buildings: 14074\n\n\n\n\n\n\n\n\n\nClass\nConfidence\nORIG_OID\nSTATUS\nShape__Area\nShape__Length\ngeometry\nDPNR_ZONE\nLand_Value\nland_value_per_m2\nmedian_suscept\nsuscept_class\n\n\n\n\n0\n\n0.0\n0\n0\n447.396912\n128.678690\nPOLYGON ((-7227123.248 2076346.558, -7227121.4...\nR-3\n0\n0.000000\n0.956010\nVery High\n\n\n1\n\n0.0\n0\n0\n87.480919\n38.886598\nPOLYGON ((-7226351.113 2076451.748, -7226360.5...\nR-1\n111400\n21.377060\n0.053907\nVery Low\n\n\n2\n\n0.0\n0\n0\n305.931160\n88.378517\nPOLYGON ((-7226367.053 2076483.508, -7226373.7...\nR-1\n264600\n71.596789\n0.042051\nVery Low\n\n\n3\n\n0.0\n0\n0\n57.737015\n30.402170\nPOLYGON ((-7226361.397 2076463.862, -7226368.2...\nR-1\n264600\n71.596789\n0.075801\nVery Low\n\n\n4\n\n0.0\n0\n0\n260.566460\n66.460525\nPOLYGON ((-7226385.420 2076522.375, -7226369.8...\nR-1\n264600\n71.596789\n0.055169\nVery Low\n\n\n\n\n\n\n\n\n# Initialize\nfig, ax = plt.subplots(figsize=(10, 6))  # adjusted size\n\n# Plot the city limits (boundary in white)\nboundary.plot(ax=ax, edgecolor=\"grey\", facecolor=\"none\", linewidth=1)\n\n# Plot the median NDVI (median_suscept) with white building outlines\nbld_res.plot(column=\"median_suscept\", legend=True, ax=ax, cmap=\"viridis\",\n             edgecolor=\"none\", linewidth=0.1)\n\n# Format\nax.set_axis_off()\nplt.tight_layout()\nout_path = images_dir / \"residence_susceptability.png\"\nplt.savefig(out_path, dpi=300, bbox_inches=\"tight\")\nprint(f\"Saved plot to {out_path}\")\n\nSaved plot to images\\residence_susceptability.png\n\n\n\n\n\n\n\n\n\n\n# Preview residential land value table \n# Keep only buildings that have valid land value info\nbld_val = bld_res.dropna(subset=[\"Land_Value\"])\nbld_val = bld_val[bld_val[\"Land_Value\"] &gt; 0].copy()\n\n# Select key columns to inspect\npreview_cols = [\n    \"Land_Value\",       # parcel land value (USD)\n    \"land_value_per_m2\",# land value per m² (USD/m²)\n    \"parcel_area_m2\",\n    \"DPNR_ZONE\",        # zoning category\n    \"median_suscept\",   # median flood susceptibility\n    \"suscept_class\",    # classified susceptibility level\n]\n\nbld_val.head()\n\n\n\n\n\n\n\n\nClass\nConfidence\nORIG_OID\nSTATUS\nShape__Area\nShape__Length\ngeometry\nDPNR_ZONE\nLand_Value\nland_value_per_m2\nmedian_suscept\nsuscept_class\n\n\n\n\n1\n\n0.0\n0\n0\n87.480919\n38.886598\nPOLYGON ((-7226351.113 2076451.748, -7226360.5...\nR-1\n111400\n21.377060\n0.053907\nVery Low\n\n\n2\n\n0.0\n0\n0\n305.931160\n88.378517\nPOLYGON ((-7226367.053 2076483.508, -7226373.7...\nR-1\n264600\n71.596789\n0.042051\nVery Low\n\n\n3\n\n0.0\n0\n0\n57.737015\n30.402170\nPOLYGON ((-7226361.397 2076463.862, -7226368.2...\nR-1\n264600\n71.596789\n0.075801\nVery Low\n\n\n4\n\n0.0\n0\n0\n260.566460\n66.460525\nPOLYGON ((-7226385.420 2076522.375, -7226369.8...\nR-1\n264600\n71.596789\n0.055169\nVery Low\n\n\n6\n\n0.0\n0\n0\n31.493248\n22.624998\nPOLYGON ((-7227102.712 2076239.331, -7227107.1...\nR-1\n118300\n61.574446\n0.296520\nLow\n\n\n\n\n\n\n\n\nimport pathlib\nimport json\nimport numpy as np\nimport pandas as pd\nimport geopandas as gpd\nimport altair as alt\nimport osmnx as ox\n\nimport geopandas as gpd\nfrom shapely.validation import make_valid \n\n# Load study area boundary and project to analysis CRS\nboundary_fp = processed / \"st_thomas_boundary.geojson\"\n\n# Read raw boundary (whatever CRS the file is in)\nboundary = gpd.read_file(boundary_fp)\n\n# Project to target_crs (e.g. EPSG:3857)\nboundary = boundary.to_crs(target_crs)\n\n# Fix invalid geometries \nboundary[\"geometry\"] = boundary.geometry.apply(make_valid)\n\n# Drop empty / null geometries\nboundary = boundary[\n    boundary.geometry.notnull() & ~boundary.geometry.is_empty\n]\n\n# Dissolve all parts into a single study-area polygon\nboundary[\"dissolve_id\"] = 1  # same value for all rows\nboundary_dissolved = boundary.dissolve(by=\"dissolve_id\")\n\n# Single Polygon (or MultiPolygon) object\nboundary_union = boundary_dissolved.geometry.iloc[0]\nboundary_single = gpd.GeoDataFrame(\n    geometry=[boundary_union],\n    crs=target_crs\n)\n\nprint(\"Boundary rows (raw):\", len(boundary))\nprint(\"Boundary union type:\", boundary_union.geom_type)\n\nBoundary rows (raw): 1\nBoundary union type: Polygon\n\n\n\nfrom shapely import make_valid\n\n# Load and project\nshelters = gpd.read_file(data_dir / \"Shelter.geojson\").to_crs(target_crs)\nshelters[\"geometry\"] = shelters.geometry.apply(make_valid)\nshelters = shelters[~shelters.geometry.is_empty]\n\n# Clip to boundary (boundary/ boundary_union already in target_crs)\nshelters = gpd.clip(shelters, boundary_union)\nshelters = shelters[~shelters.geometry.is_empty]\n\n# IDs/names\nif \"shelter_id\" not in shelters.columns:\n    shelters[\"shelter_id\"] = shelters.index.astype(str)\nif \"name\" not in shelters.columns:\n    shelters[\"name\"] = shelters.index.astype(str)\n\nprint(\"Shelters after clip:\", shelters.shape)\nshelters.head()\n\nShelters after clip: (6, 8)\n\n\n\n\n\n\n\n\n\nFID\nName\nLatitude\nLongitude\nIsland\ngeometry\nshelter_id\nname\n\n\n\n\n5\n5\nBertha B. Boschulte School\n18.317206\n-64.891119\nSt.Thomas\nPOINT (-7223646.324 2074710.573)\n5\n5\n\n\n0\n0\nSugar Estate Head Start Center\n18.339801\n-64.920562\nSt.Thomas\nPOINT (-7226923.904 2077360.258)\n0\n0\n\n\n1\n1\nCommunity Health Clinic at Schneider\n18.340168\n-64.914869\nSt.Thomas\nPOINT (-7226290.162 2077403.298)\n1\n1\n\n\n4\n4\nCharlotte Amalie High School Auditorium\n18.341186\n-64.919949\nSt.Thomas\nPOINT (-7226855.665 2077522.686)\n4\n4\n\n\n2\n2\nLockhart Elementary\n18.341674\n-64.916455\nSt.Thomas\nPOINT (-7226466.715 2077579.917)\n2\n2\n\n\n\n\n\n\n\n\n!pip install pandana \n\nimport pandana as pdna\nfrom pandana.loaders import osm\nimport pandas as pd\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nfrom shapely.geometry import Point\n\nRequirement already satisfied: pandana in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (0.7)\nRequirement already satisfied: numpy&gt;=1.8 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from pandana) (1.24.4)\nRequirement already satisfied: pandas&gt;=0.17 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from pandana) (1.5.3)\nRequirement already satisfied: requests&gt;=2.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from pandana) (2.31.0)\nRequirement already satisfied: scikit-learn&gt;=0.18 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from pandana) (1.3.0)\nRequirement already satisfied: tables&gt;=3.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from pandana) (3.8.0)\nRequirement already satisfied: python-dateutil&gt;=2.8.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from pandas&gt;=0.17-&gt;pandana) (2.9.0.post0)\nRequirement already satisfied: pytz&gt;=2020.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from pandas&gt;=0.17-&gt;pandana) (2025.2)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests&gt;=2.0-&gt;pandana) (3.4.3)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests&gt;=2.0-&gt;pandana) (3.10)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests&gt;=2.0-&gt;pandana) (1.26.19)\nRequirement already satisfied: certifi&gt;=2017.4.17 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests&gt;=2.0-&gt;pandana) (2025.11.12)\nRequirement already satisfied: scipy&gt;=1.5.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from scikit-learn&gt;=0.18-&gt;pandana) (1.15.2)\nRequirement already satisfied: joblib&gt;=1.1.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from scikit-learn&gt;=0.18-&gt;pandana) (1.5.2)\nRequirement already satisfied: threadpoolctl&gt;=2.0.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from scikit-learn&gt;=0.18-&gt;pandana) (3.6.0)\nRequirement already satisfied: numexpr&gt;=2.6.2 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from tables&gt;=3.1-&gt;pandana) (2.10.2)\nRequirement already satisfied: packaging in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from tables&gt;=3.1-&gt;pandana) (25.0)\nRequirement already satisfied: py-cpuinfo in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from tables&gt;=3.1-&gt;pandana) (9.0.0)\nRequirement already satisfied: six&gt;=1.5 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from python-dateutil&gt;=2.8.1-&gt;pandas&gt;=0.17-&gt;pandana) (1.17.0)\n\n\n\n# Build Pandana network from St Thomas bbox\n# Reproject boundary to WGS84 and get bounding box\nboundary_wgs = gpd.GeoSeries([boundary_union], crs=target_crs).to_crs(\"EPSG:4326\")\nlng_min, lat_min, lng_max, lat_max = boundary_wgs.total_bounds\nprint(\"BBox (WGS84):\", lat_min, lng_min, lat_max, lng_max)\n\n# Build WALK network with Pandana\nnet = osm.pdna_network_from_bbox(\n    lat_min, lng_min, lat_max, lng_max,\n    network_type=\"walk\"\n)\nprint(\"Pandana network nodes:\", len(net.nodes_df), \"edges:\", len(net.edges_df))\n\n# Prepare shelters as POIs in WGS84\nshelters_wgs = shelters.to_crs(\"EPSG:4326\").copy()\n\nif \"shelter_id\" not in shelters_wgs.columns:\n    shelters_wgs[\"shelter_id\"] = shelters_wgs.index.astype(str)\nif \"name\" not in shelters_wgs.columns:\n    shelters_wgs[\"name\"] = shelters_wgs[\"shelter_id\"]\n\nmax_distance = 4000  # meters\nnum_pois = 1         # nearest shelter only\n\nnet.set_pois(\n    \"shelter\",\n    max_distance,\n    num_pois,\n    shelters_wgs.geometry.x.values,\n    shelters_wgs.geometry.y.values\n)\nprint(\"Shelter POIs registered.\")\n\nBBox (WGS84): 18.302428399999997 -65.0421288 18.3833342 -64.8317848\nRequesting network data within bounding box from Overpass API in 1 request(s)\nPosting to http://www.overpass-api.de/api/interpreter with timeout=180, \"{'data': '[out:json][timeout:180];(way[\"highway\"][\"highway\"!~\"motor|proposed|construction|abandoned|platform|raceway\"][\"foot\"!~\"no\"][\"pedestrians\"!~\"no\"](18.30242840,-65.04212880,18.38333420,-64.83178480);&gt;;);out;'}\"\nDownloaded 3,672.5KB from www.overpass-api.de in 0.97 seconds\nDownloaded OSM network data within bounding box from Overpass API in 1 request(s) and 1.04 seconds\nReturning OSM data with 31,129 nodes and 3,571 ways...\nEdge node pairs completed. Took 1.82 seconds\nReturning processed graph with 3,774 nodes and 4,605 edges...\nCompleted OSM data download and Pandana node and edge table creation in 3.23 seconds\nPandana network nodes: 3774 edges: 4647\nShelter POIs registered.\n\n\n\n# Compute distance from each network node to nearest shelter\naccess = net.nearest_pois(\n    distance=max_distance,\n    category=\"shelter\",\n    num_pois=num_pois\n)\nprint(\"Access head:\")\ndisplay(access.head())\n\n# Merge node coordinates with distances\nnodes = pd.merge(net.nodes_df, access, left_index=True, right_index=True)\nnodes.rename(columns={1: \"dist_to_shelter_m\"}, inplace=True)\n\n# Make GeoDataFrame in WGS84\nnodes_gdf = gpd.GeoDataFrame(\n    nodes,\n    geometry=gpd.points_from_xy(nodes[\"x\"], nodes[\"y\"]),\n    crs=\"EPSG:4326\"\n)\n\n# Reproject nodes to target_crs (EPSG:3857) for distance calc with buildings\nnodes_gdf_3857 = nodes_gdf.to_crs(target_crs).copy()\n\nprint(\"Nodes with distance to shelter (head):\")\ndisplay(nodes_gdf_3857.head())\n\nAccess head:\n\n\n\n\n\n\n\n\n\n1\n\n\nid\n\n\n\n\n\n249647430\n3467.790039\n\n\n249900105\n4000.000000\n\n\n249900121\n4000.000000\n\n\n249900132\n4000.000000\n\n\n249900149\n4000.000000\n\n\n\n\n\n\n\nNodes with distance to shelter (head):\n\n\n\n\n\n\n\n\n\nx\ny\ndist_to_shelter_m\ngeometry\n\n\nid\n\n\n\n\n\n\n\n\n249647430\n-64.952149\n18.334457\n3467.790039\nPOINT (-7230440.119 2076733.484)\n\n\n249900105\n-64.852174\n18.332734\n4000.000000\nPOINT (-7219310.975 2076531.518)\n\n\n249900121\n-64.855298\n18.335413\n4000.000000\nPOINT (-7219658.715 2076845.656)\n\n\n249900132\n-64.857668\n18.336584\n4000.000000\nPOINT (-7219922.554 2076982.995)\n\n\n249900149\n-64.863064\n18.340887\n4000.000000\nPOINT (-7220523.289 2077487.608)\n\n\n\n\n\n\n\n\n# Create centroids for residential buildings (keep all attributes)\nbld_centroids = bld_val.copy()\nbld_centroids[\"geometry\"] = bld_centroids.geometry.centroid\n\n# Ensure building ID exists\nif \"bld_id\" not in bld_centroids.columns:\n    bld_centroids[\"bld_id\"] = bld_centroids.index.astype(str)\n\nprint(\"Preview centroid table:\")\ndisplay(\n    bld_centroids[\n        [\n            \"bld_id\",\n            \"Land_Value\",\n            \"land_value_per_m2\",\n            \"DPNR_ZONE\",\n            \"median_suscept\",\n            \"suscept_class\",\n            \"geometry\",\n        ]\n    ].head()\n)\n\nPreview centroid table:\n\n\n\n\n\n\n\n\n\nbld_id\nLand_Value\nland_value_per_m2\nDPNR_ZONE\nmedian_suscept\nsuscept_class\ngeometry\n\n\n\n\n1\n1\n111400\n21.377060\nR-1\n0.053907\nVery Low\nPOINT (-7226358.391 2076449.909)\n\n\n2\n2\n264600\n71.596789\nR-1\n0.042051\nVery Low\nPOINT (-7226372.050 2076483.505)\n\n\n3\n3\n264600\n71.596789\nR-1\n0.075801\nVery Low\nPOINT (-7226366.972 2076464.853)\n\n\n4\n4\n264600\n71.596789\nR-1\n0.055169\nVery Low\nPOINT (-7226378.245 2076514.560)\n\n\n6\n6\n118300\n61.574446\nR-1\n0.296520\nLow\nPOINT (-7227102.998 2076243.592)\n\n\n\n\n\n\n\n\n# Simple nearest-node function \ndef nearest_node_id(point):\n    \"\"\"\n    Return the ID of the nearest Pandana/network node for a given Point.\n    Both buildings and nodes are in target_crs (e.g., EPSG:3857).\n    This version computes distance to ALL nodes (simple but robust).\n    \"\"\"\n    if point is None or point.is_empty:\n        return None\n\n    # Distance from this building centroid to all nodes\n    dists = nodes_gdf_3857.geometry.distance(point)\n\n    # If all NaN \n    if dists.isna().all():\n        return None\n\n    # Return index label of closest node \n    return dists.idxmin()\n\n# Apply to every centroid\nbld_centroids[\"nearest_node\"] = bld_centroids.geometry.apply(nearest_node_id)\n\nprint(\"Preview nearest_node values:\")\ndisplay(bld_centroids[[\"bld_id\", \"nearest_node\"]].head())\n\nPreview nearest_node values:\n\n\n\n\n\n\n\n\n\nbld_id\nnearest_node\n\n\n\n\n1\n1\n280447904\n\n\n2\n2\n280447904\n\n\n3\n3\n280447904\n\n\n4\n4\n280447904\n\n\n6\n6\n251720799\n\n\n\n\n\n\n\n\n# Attach walking distance from nodes to buildings\nbld_with_access = bld_centroids.merge(\n    nodes_gdf_3857[[\"dist_to_shelter_m\"]],\n    left_on=\"nearest_node\",\n    right_index=True,\n    how=\"left\",\n)\n\nprint(\"Buildings with walking distance to nearest shelter (head):\")\ndisplay(bld_with_access[[\"bld_id\", \"nearest_node\", \"dist_to_shelter_m\"]].head())\n\nBuildings with walking distance to nearest shelter (head):\n\n\n\n\n\n\n\n\n\nbld_id\nnearest_node\ndist_to_shelter_m\n\n\n\n\n1\n1\n280447904\n1767.099976\n\n\n2\n2\n280447904\n1767.099976\n\n\n3\n3\n280447904\n1767.099976\n\n\n4\n4\n280447904\n1767.099976\n\n\n6\n6\n251720799\n1313.702026\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nimport geopandas as gpd\n\n# Align CRS\nboundary_3857 = boundary.to_crs(target_crs)\nshelters_3857 = shelters.to_crs(target_crs).copy()\n\n# Fix boundary and build a union\nboundary_union = boundary_3857.buffer(0).unary_union\n\n# Clip nodes to boundary\nnodes_clipped = nodes_gdf_3857[\n    nodes_gdf_3857.geometry.within(boundary_union)\n].copy()\n\ndef plot_walking_distance_to_shelter(\n    nodes_gdf_3857,\n    shelters_3857,\n    column=\"dist_to_shelter_m\"\n):\n    fig, ax = plt.subplots(figsize=(10, 10))\n    divider = make_axes_locatable(ax)\n    cax = divider.append_axes(\"right\", size=\"5%\", pad=0.1)\n\n    # Plot clipped nodes colored by walking distance\n    plot_kwargs = {\"s\": 10, \"alpha\": 0.9, \"cmap\": \"viridis_r\", \"edgecolor\": \"none\"}\n    scatter = nodes_gdf_3857.plot(\n        ax=ax,\n        cax=cax,\n        column=column,\n        legend=True,\n        **plot_kwargs\n    )\n\n    # Add shelters as red stars\n    shelters_3857.plot(ax=ax, color=\"red\", markersize=50, marker=\"*\", label=\"Shelters\")\n\n    # Add boundary\n    boundary_3857.boundary.plot(ax=ax, edgecolor=\"white\", linewidth=1)\n\n    # Formatting\n    fig.patch.set_facecolor(\"#2b005a\")\n    ax.set_facecolor(\"#2b005a\")\n    xmin, ymin, xmax, ymax = boundary_3857.total_bounds\n    ax.set_xlim(xmin, xmax)\n    ax.set_ylim(ymin, ymax)\n    ax.set_axis_off()\n\n    # Legend styling\n    leg = ax.legend()\n    if leg:\n        for txt in leg.get_texts():\n            txt.set_color(\"white\")\n        leg.get_frame().set_facecolor(\"#2b005a\")\n        leg.get_frame().set_edgecolor(\"white\")\n\n    plt.tight_layout()\n    return ax\n\n# Example usage:\nax = plot_walking_distance_to_shelter(\n    nodes_gdf_3857=nodes_clipped,\n    shelters_3857=shelters_3857,\n    column=\"dist_to_shelter_m\"\n)\n\nout_path = images_dir / \"walking_distance_to_nearest_shelter.png\"\nplt.savefig(out_path, dpi=300, bbox_inches=\"tight\")\nprint(f\"Saved plot to {out_path}\")\n\nSaved plot to images\\walking_distance_to_nearest_shelter.png\n\n\n\n\n\n\n\n\n\n\nimport altair as alt\n\n# Palette for susceptibility\nsuscept_order = [\"Very Low\", \"Low\", \"Moderate\", \"High\", \"Very High\"]\ncolors = [\"#2ca25f\", \"#99d8c9\", \"#fed98e\", \"#f46d43\", \"#bd0026\"]  # match legend\n\nalt.data_transformers.disable_max_rows()\n\n# Drop rows missing key fields\ndf_raw = bld_with_access.dropna(subset=[\"land_value_per_m2\", \"dist_to_shelter_m\", \"suscept_class\"]).copy()\n\n# Remove extreme outliers (99th percentile cap)\nupper_cap = df_raw[\"land_value_per_m2\"].quantile(0.99)\ndf = df_raw[df_raw[\"land_value_per_m2\"] &lt;= upper_cap]\n\n# Base scatter with custom colors\nbase = (\n    alt.Chart(df)\n    .mark_circle(size=60, opacity=0.6)\n    .encode(\n        x=alt.X(\"land_value_per_m2:Q\", scale=alt.Scale(zero=False), title=\"Land Value per m² (USD)\"),\n        y=alt.Y(\"dist_to_shelter_m:Q\", scale=alt.Scale(zero=False), title=\"Distance to Shelter (m)\"),\n        color=alt.Color(\n            \"suscept_class:N\",\n            title=\"Flood Susceptibility\",\n            scale=alt.Scale(domain=suscept_order, range=colors),\n        ),\n        tooltip=[\n            alt.Tooltip(\"land_value_per_m2:Q\", title=\"Land Value per m²\"),\n            alt.Tooltip(\"dist_to_shelter_m:Q\", title=\"Distance to Shelter (m)\"),\n            alt.Tooltip(\"suscept_class:N\", title=\"Susceptibility\"),\n        ],\n    )\n)\n\n# Regression line \ntrend = (\n    alt.Chart(df)\n    .transform_regression(\"land_value_per_m2\", \"dist_to_shelter_m\")\n    .mark_line(color=\"#1f4e63\")\n    .encode(\n        x=alt.X(\"land_value_per_m2:Q\", scale=alt.Scale(zero=False)),\n        y=alt.Y(\"dist_to_shelter_m:Q\", scale=alt.Scale(zero=False)),\n    )\n)\n\nchart = (\n    (base + trend)\n    .properties(\n        width=600,\n        height=400,\n    )\n    .interactive()\n)\n\nchart\nchart.save(\"vis/landvalue_shelter_scatter.html\")\n\n\nsuscept_order = [\"Very Low\", \"Low\", \"Moderate\", \"High\", \"Very High\"]\n\n# ensure categorical order (optional)\nbld_with_access[\"suscept_class\"] = pd.Categorical(\n    bld_with_access[\"suscept_class\"], categories=suscept_order, ordered=True\n)\n\n# counts and proportions\ncounts = bld_with_access[\"suscept_class\"].value_counts(dropna=False)\nprops = bld_with_access[\"suscept_class\"].value_counts(normalize=True, dropna=False)\n\nprint(\"Counts:\")\nprint(counts.reindex(suscept_order))\nprint(\"\\nProportions:\")\nprint(props.reindex(suscept_order))\n\nCounts:\nVery Low     5757\nLow          3625\nModerate     1383\nHigh         1051\nVery High    1470\nName: suscept_class, dtype: int64\n\nProportions:\nVery Low     0.433313\nLow          0.272844\nModerate     0.104095\nHigh         0.079106\nVery High    0.110643\nName: suscept_class, dtype: float64\n\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nsuscept_order = [\"Very Low\", \"Low\", \"Moderate\", \"High\", \"Very High\"]\ncolors = [\"#2ca25f\", \"#99d8c9\", \"#fed98e\", \"#f46d43\", \"#bd0026\"]  # match legend\n\nbld_with_access[\"suscept_class\"] = pd.Categorical(\n    bld_with_access[\"suscept_class\"], categories=suscept_order, ordered=True\n)\nprops = bld_with_access[\"suscept_class\"].value_counts(normalize=True).reindex(suscept_order)\n\nfig, ax = plt.subplots(figsize=(6, 4))\nprops.plot.bar(ax=ax, color=colors)\nax.set_ylabel(\"Proportion\")\nax.set_xlabel(\"Susceptibility Class\")\nax.set_ylim(0, 1)\nplt.tight_layout()\n\nout_path = images_dir / \"classproportion.png\"\nplt.savefig(out_path, dpi=300, bbox_inches=\"tight\")\nprint(f\"Saved plot to {out_path}\")\n\nSaved plot to images\\classproportion.png\n\n\n\n\n\n\n\n\n\n\nimport geopandas as gpd\nimport pandas as pd\nimport folium\n\ncrs_proj = \"EPSG:3857\"\n\n# Project working copies\nboundary_3857  = boundary.to_crs(crs_proj)\nbuildings_3857 = buildings.to_crs(crs_proj)\nbld_3857       = bld_with_access.to_crs(crs_proj).copy()\nshelters_3857  = shelters.to_crs(crs_proj).copy()\n\n# Map center from boundary centroid (projected -&gt; WGS84)\nctr_proj = boundary_3857.geometry.centroid\nctr_wgs = gpd.GeoSeries(ctr_proj, crs=crs_proj).to_crs(\"EPSG:4326\")\ncenter_lat = ctr_wgs.y.mean()\ncenter_lon = ctr_wgs.x.mean()\n\n# Web copies (WGS84) for Folium\nboundary_web  = boundary_3857.to_crs(\"EPSG:4326\")\nbuildings_web = buildings_3857.to_crs(\"EPSG:4326\")\nbld_web       = bld_3857.to_crs(\"EPSG:4326\").copy()\nshelters_web  = shelters_3857.to_crs(\"EPSG:4326\").copy()\n\n# Susceptibility categories/colors\nsuscept_order  = [\"Very Low\", \"Low\", \"Moderate\", \"High\", \"Very High\"]\nsuscept_colors = [\"#2ca25f\", \"#99d8c9\", \"#fed98e\", \"#f46d43\", \"#bd0026\"]\nbld_web[\"suscept_class\"] = pd.Categorical(\n    bld_web[\"suscept_class\"], categories=suscept_order, ordered=True\n)\n\n# Build map\nm = folium.Map(location=[center_lat, center_lon], zoom_start=12, tiles=\"CartoDB positron\")\n\n# Boundary\nboundary_web.explore(\n    name=\"Boundary\",\n    style_kwds={\"color\": \"black\", \"fillColor\": \"none\", \"weight\": 2},\n    tiles=None, show=True, popup=False, tooltip=False, m=m,\n)\n\n# Buildings colored by susceptibility \nbld_web.explore(\n    column=\"suscept_class\",\n    cmap=suscept_colors,\n    categorical=True,\n    legend=True,\n    legend_kwds={\"caption\": \"Flood Susceptibility\"},\n    tooltip=[\"bld_id\", \"median_suscept\", \"land_value_per_m2\", \"dist_to_shelter_m\"],\n    popup=[\"bld_id\", \"median_suscept\", \"land_value_per_m2\", \"dist_to_shelter_m\"],\n    name=\"Buildings (colored)\",\n    tiles=None,\n    m=m,\n    marker_kwds={\"radius\": 3},  \n)\n\n# Shelters with name on hover/click\nshelters_web.explore(\n    name=\"Shelters\",\n    tiles=None,\n    m=m,\n    marker_type=\"marker\",\n    marker_kwds={\"icon\": folium.Icon(color=\"red\", icon=\"star\")},\n    tooltip=[\"Name\"],   \n    popup=[\"Name\"],  \n)\n\n# Simple shelter legend (red star)\nlegend_html = \"\"\"\n&lt;div style=\"\n position: fixed; \n bottom: 50px; left: 50px; width: 160px; height: 40px; \n background: white; border:2px solid #444; z-index:9999; font-size:14px;\n padding:6px;\"&gt;\n&lt;b&gt;Legend&lt;/b&gt;&lt;br&gt;\n&lt;span style='color:red;'&gt;&#9733;&lt;/span&gt; Shelter\n&lt;/div&gt;\n\"\"\"\nm.get_root().html.add_child(folium.Element(legend_html))\n\nfolium.LayerControl().add_to(m)\n\nm\nm.save(\"vis/flood_buildings_map.html\")\nprint(\"Saved: flood_buildings_map.html\")\n\nSaved: flood_buildings_map.html"
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Exploring the Flood Risk in St. Thomas",
    "section": "Overview",
    "text": "Overview\nSteep topography and coastal concentration of development make small island cities highly sensitive to flooding, and St. Thomas in the U.S. Virgin Islands is no exception. Seasonal storms, intense rainfall, and limited drainage capacity amplify water accumulation across hillside neighborhoods and low-lying coastal communities. In this project, community-level flood risk in St. Thomas is assessed using a Python and machine-learning framework that integrates flood susceptibility with indicators of community exposure. By mapping the spatial pattern of flood exposure, identifying key environmental drivers, and comparing socio-spatial disparities, such as shelter accessibility and variations in land value, the analysis provides essential insights for understanding flood exposure, locating safe shelters, and planning appropriate insurance coverage.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "exposure-disparities.html",
    "href": "exposure-disparities.html",
    "title": "Exposure Disparities",
    "section": "",
    "text": "Grouping residential parcels by land value and analyzing their distance to shelters reveals a distinct pattern of exposure disparity. Lower-value parcels, particularly those below 200 USD per square meter, are located farther from designated shelters, with many exceeding distances of 2,500 to 4,000 meters. This suggests that lower-income communities require longer travel times during emergencies, resulting in higher evacuation costs and slower response capabilities.\nA second pattern emerges when considering flood susceptibility. High and very high susceptibility parcels are disproportionately concentrated within the lower land value range. This indicates a spatial overlap between economic disadvantage and hazard exposure—a condition often associated with environmental and climate justice inequities, where the communities least able to mitigate risks are the most exposed to them.\nConversely, parcels of higher land value are generally located closer to shelters, as reflected in the downward trend in the plot. These areas are more likely to benefit from better infrastructure, public services, and emergency facilities, underscoring structural unevenness in the distribution of safety-related resources.\n\n\nCode\nimport altair as alt\n\n# Palette for susceptibility\nsuscept_order = [\"Very Low\", \"Low\", \"Moderate\", \"High\", \"Very High\"]\ncolors = [\"#2ca25f\", \"#99d8c9\", \"#fed98e\", \"#f46d43\", \"#bd0026\"]  # match legend\n\nalt.data_transformers.disable_max_rows()\n\n# Drop rows missing key fields\ndf_raw = bld_with_access.dropna(subset=[\"land_value_per_m2\", \"dist_to_shelter_m\", \"suscept_class\"]).copy()\n\n# Remove extreme outliers (99th percentile cap)\nupper_cap = df_raw[\"land_value_per_m2\"].quantile(0.99)\ndf = df_raw[df_raw[\"land_value_per_m2\"] &lt;= upper_cap]\n\n# Base scatter with custom colors\nbase = (\n    alt.Chart(df)\n    .mark_circle(size=60, opacity=0.6)\n    .encode(\n        x=alt.X(\"land_value_per_m2:Q\", scale=alt.Scale(zero=False), title=\"Land Value per m² (USD)\"),\n        y=alt.Y(\"dist_to_shelter_m:Q\", scale=alt.Scale(zero=False), title=\"Distance to Shelter (m)\"),\n        color=alt.Color(\n            \"suscept_class:N\",\n            title=\"Flood Susceptibility\",\n            scale=alt.Scale(domain=suscept_order, range=colors),\n        ),\n        tooltip=[\n            alt.Tooltip(\"land_value_per_m2:Q\", title=\"Land Value per m²\"),\n            alt.Tooltip(\"dist_to_shelter_m:Q\", title=\"Distance to Shelter (m)\"),\n            alt.Tooltip(\"suscept_class:N\", title=\"Susceptibility\"),\n        ],\n    )\n)\n\n# Regression line \ntrend = (\n    alt.Chart(df)\n    .transform_regression(\"land_value_per_m2\", \"dist_to_shelter_m\")\n    .mark_line(color=\"#1f4e63\")\n    .encode(\n        x=alt.X(\"land_value_per_m2:Q\", scale=alt.Scale(zero=False)),\n        y=alt.Y(\"dist_to_shelter_m:Q\", scale=alt.Scale(zero=False)),\n    )\n)\n\nchart = (\n    (base + trend)\n    .properties(\n        width=600,\n        height=400,\n    )\n    .interactive()\n)\n\nchart\n\n\n\n  \n  \n  \n    Figure 1: Land Value per m² vs. Distance to Shelter",
    "crumbs": [
      "Results: Risk Management",
      "Exposure Disparities"
    ]
  },
  {
    "objectID": "exposure-disparities.html#disparities-analysis",
    "href": "exposure-disparities.html#disparities-analysis",
    "title": "Exposure Disparities",
    "section": "",
    "text": "Grouping residential parcels by land value and analyzing their distance to shelters reveals a distinct pattern of exposure disparity. Lower-value parcels, particularly those below 200 USD per square meter, are located farther from designated shelters, with many exceeding distances of 2,500 to 4,000 meters. This suggests that lower-income communities require longer travel times during emergencies, resulting in higher evacuation costs and slower response capabilities.\nA second pattern emerges when considering flood susceptibility. High and very high susceptibility parcels are disproportionately concentrated within the lower land value range. This indicates a spatial overlap between economic disadvantage and hazard exposure—a condition often associated with environmental and climate justice inequities, where the communities least able to mitigate risks are the most exposed to them.\nConversely, parcels of higher land value are generally located closer to shelters, as reflected in the downward trend in the plot. These areas are more likely to benefit from better infrastructure, public services, and emergency facilities, underscoring structural unevenness in the distribution of safety-related resources.\n\n\nCode\nimport altair as alt\n\n# Palette for susceptibility\nsuscept_order = [\"Very Low\", \"Low\", \"Moderate\", \"High\", \"Very High\"]\ncolors = [\"#2ca25f\", \"#99d8c9\", \"#fed98e\", \"#f46d43\", \"#bd0026\"]  # match legend\n\nalt.data_transformers.disable_max_rows()\n\n# Drop rows missing key fields\ndf_raw = bld_with_access.dropna(subset=[\"land_value_per_m2\", \"dist_to_shelter_m\", \"suscept_class\"]).copy()\n\n# Remove extreme outliers (99th percentile cap)\nupper_cap = df_raw[\"land_value_per_m2\"].quantile(0.99)\ndf = df_raw[df_raw[\"land_value_per_m2\"] &lt;= upper_cap]\n\n# Base scatter with custom colors\nbase = (\n    alt.Chart(df)\n    .mark_circle(size=60, opacity=0.6)\n    .encode(\n        x=alt.X(\"land_value_per_m2:Q\", scale=alt.Scale(zero=False), title=\"Land Value per m² (USD)\"),\n        y=alt.Y(\"dist_to_shelter_m:Q\", scale=alt.Scale(zero=False), title=\"Distance to Shelter (m)\"),\n        color=alt.Color(\n            \"suscept_class:N\",\n            title=\"Flood Susceptibility\",\n            scale=alt.Scale(domain=suscept_order, range=colors),\n        ),\n        tooltip=[\n            alt.Tooltip(\"land_value_per_m2:Q\", title=\"Land Value per m²\"),\n            alt.Tooltip(\"dist_to_shelter_m:Q\", title=\"Distance to Shelter (m)\"),\n            alt.Tooltip(\"suscept_class:N\", title=\"Susceptibility\"),\n        ],\n    )\n)\n\n# Regression line \ntrend = (\n    alt.Chart(df)\n    .transform_regression(\"land_value_per_m2\", \"dist_to_shelter_m\")\n    .mark_line(color=\"#1f4e63\")\n    .encode(\n        x=alt.X(\"land_value_per_m2:Q\", scale=alt.Scale(zero=False)),\n        y=alt.Y(\"dist_to_shelter_m:Q\", scale=alt.Scale(zero=False)),\n    )\n)\n\nchart = (\n    (base + trend)\n    .properties(\n        width=600,\n        height=400,\n    )\n    .interactive()\n)\n\nchart\n\n\n\n  \n  \n  \n    Figure 1: Land Value per m² vs. Distance to Shelter",
    "crumbs": [
      "Results: Risk Management",
      "Exposure Disparities"
    ]
  },
  {
    "objectID": "community-flood-risk-map.html",
    "href": "community-flood-risk-map.html",
    "title": "Community Flood Risk Map",
    "section": "",
    "text": "Each residential building was assigned a flood-susceptibility score derived from the model-predicted median_suscept value. To facilitate categorical interpretation, these continuous susceptibility scores were discretized into five fixed-interval classes: 0–0.2 (Very Low), 0.2–0.4 (Low), 0.4–0.6 (Moderate), 0.6–0.8 (High), and 0.8–1.0 (Very High). This classification scheme generates a discrete risk label for every residential structure, enabling subsequent analyses to directly compare building-level exposure and communicate flood risk more effectively.\nThe results show that 43.3% and 27.3% of buildings fall into the “very low” and “low” risk categories, respectively, indicating that most buildings are in areas of low vulnerability. In contrast, the “very high” risk category covers 11.1% of buildings, suggesting these structures may be situated in flood-prone locations.\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nsuscept_order = [\"Very Low\", \"Low\", \"Moderate\", \"High\", \"Very High\"]\ncolors = [\"#2ca25f\", \"#99d8c9\", \"#fed98e\", \"#f46d43\", \"#bd0026\"]  # match legend\n\nbld_with_access[\"suscept_label\"] = pd.Categorical(\n    bld_with_access[\"suscept_label\"], categories=suscept_order, ordered=True\n)\nprops = bld_with_access[\"suscept_label\"].value_counts(normalize=True).reindex(suscept_order)\n\nfig, ax = plt.subplots(figsize=(6, 4))\nprops.plot.bar(ax=ax, color=colors)\nax.set_ylabel(\"Proportion\")\nax.set_xlabel(\"Susceptibility Class\")\nax.set_title(\"Class Proportions\")\nax.set_ylim(0, 1)\nplt.show()\n\n\n\n\n\nFigure 1: Plot of Community Flood Risk Level",
    "crumbs": [
      "Results: Risk Management",
      "Community Flood Risk Map"
    ]
  },
  {
    "objectID": "community-flood-risk-map.html#residential-building-flood-susceptibility",
    "href": "community-flood-risk-map.html#residential-building-flood-susceptibility",
    "title": "Community Flood Risk Map",
    "section": "",
    "text": "Each residential building was assigned a flood-susceptibility score derived from the model-predicted median_suscept value. To facilitate categorical interpretation, these continuous susceptibility scores were discretized into five fixed-interval classes: 0–0.2 (Very Low), 0.2–0.4 (Low), 0.4–0.6 (Moderate), 0.6–0.8 (High), and 0.8–1.0 (Very High). This classification scheme generates a discrete risk label for every residential structure, enabling subsequent analyses to directly compare building-level exposure and communicate flood risk more effectively.\nThe results show that 43.3% and 27.3% of buildings fall into the “very low” and “low” risk categories, respectively, indicating that most buildings are in areas of low vulnerability. In contrast, the “very high” risk category covers 11.1% of buildings, suggesting these structures may be situated in flood-prone locations.\n\n\nCode\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nsuscept_order = [\"Very Low\", \"Low\", \"Moderate\", \"High\", \"Very High\"]\ncolors = [\"#2ca25f\", \"#99d8c9\", \"#fed98e\", \"#f46d43\", \"#bd0026\"]  # match legend\n\nbld_with_access[\"suscept_label\"] = pd.Categorical(\n    bld_with_access[\"suscept_label\"], categories=suscept_order, ordered=True\n)\nprops = bld_with_access[\"suscept_label\"].value_counts(normalize=True).reindex(suscept_order)\n\nfig, ax = plt.subplots(figsize=(6, 4))\nprops.plot.bar(ax=ax, color=colors)\nax.set_ylabel(\"Proportion\")\nax.set_xlabel(\"Susceptibility Class\")\nax.set_title(\"Class Proportions\")\nax.set_ylim(0, 1)\nplt.show()\n\n\n\n\n\nFigure 1: Plot of Community Flood Risk Level",
    "crumbs": [
      "Results: Risk Management",
      "Community Flood Risk Map"
    ]
  },
  {
    "objectID": "community-flood-risk-map.html#community-flood-risk-map",
    "href": "community-flood-risk-map.html#community-flood-risk-map",
    "title": "Community Flood Risk Map",
    "section": "Community Flood Risk Map",
    "text": "Community Flood Risk Map\nThe community flood-risk interactive map provides a critical foundation for risk management by translating model outputs into an accessible, spatially explicit decision-support tool. As shown in the flood-susceptibility map, several risk clusters emerge across St. Thomas that align closely with the island’s topography and settlement patterns. High and very high susceptibility points concentrate along the southern coastal corridor from Charlotte Amalie West through Charlotte Amalie East, extending toward Bovoni and the industrial-residential areas near Tutu. Additional hotspots appear along the eastern coastline from Nazareth to Red Hook, where dense shoreline development sits adjacent to steep inland slopes. On the northern side of the island, smaller pockets of elevated risk are observed around Magens Bay, Peterborg, and the surrounding hillside communities, where steep terrain funnels runoff toward coastal properties.\nIn contrast, the island’s interior ridge, from Caret Bay Estate through John Oley and into the central uplands, is predominantly categorized as very low to low susceptibility, reflecting higher elevations and lower exposure to coastal and drainage-channel flooding. However, several inland depressions near Anna’s Retreat and the downstream valleys feeding into Charlotte Amalie Harbor exhibit moderate to high sensitivity, suggesting vulnerability to stormwater accumulation.\n\n\nCode\nimport geopandas as gpd\nimport pandas as pd\nimport folium\n\ncrs_proj = \"EPSG:3857\"\n\n# Project working copies\nboundary_3857  = boundary.to_crs(crs_proj)\nbuildings_3857 = buildings.to_crs(crs_proj)\nbld_3857       = bld_with_access.to_crs(crs_proj).copy()\nshelters_3857  = shelters.to_crs(crs_proj).copy()\n\n# Map center from boundary centroid (projected -&gt; WGS84)\nctr_proj = boundary_3857.geometry.centroid\nctr_wgs = gpd.GeoSeries(ctr_proj, crs=crs_proj).to_crs(\"EPSG:4326\")\ncenter_lat = ctr_wgs.y.mean()\ncenter_lon = ctr_wgs.x.mean()\n\n# Web copies (WGS84) for Folium\nboundary_web  = boundary_3857.to_crs(\"EPSG:4326\")\nbuildings_web = buildings_3857.to_crs(\"EPSG:4326\")\nbld_web       = bld_3857.to_crs(\"EPSG:4326\").copy()\nshelters_web  = shelters_3857.to_crs(\"EPSG:4326\").copy()\n\n# Susceptibility categories/colors\nsuscept_order  = [\"Very Low\", \"Low\", \"Moderate\", \"High\", \"Very High\"]\nsuscept_colors = [\"#2ca25f\", \"#99d8c9\", \"#fed98e\", \"#f46d43\", \"#bd0026\"]\nbld_web[\"suscept_label\"] = pd.Categorical(\n    bld_web[\"suscept_label\"], categories=suscept_order, ordered=True\n)\n\n# Build map\nm = folium.Map(location=[center_lat, center_lon], zoom_start=12, tiles=\"CartoDB positron\")\n\n# Boundary\nboundary_web.explore(\n    name=\"Boundary\",\n    style_kwds={\"color\": \"black\", \"fillColor\": \"none\", \"weight\": 2},\n    tiles=None, show=True, popup=False, tooltip=False, m=m,\n)\n\n# Buildings colored by susceptibility \nbld_web.explore(\n    column=\"suscept_label\",\n    cmap=suscept_colors,\n    categorical=True,\n    legend=True,\n    legend_kwds={\"caption\": \"Flood Susceptibility\"},\n    tooltip=[\"bld_id\", \"median_suscept\", \"land_value_per_m2\", \"dist_to_shelter_m\"],\n    popup=[\"bld_id\", \"median_suscept\", \"land_value_per_m2\", \"dist_to_shelter_m\"],\n    name=\"Buildings (colored)\",\n    tiles=None,\n    m=m,\n    marker_kwds={\"radius\": 3},  \n)\n\n# Shelters with name on hover/click\nshelters_web.explore(\n    name=\"Shelters\",\n    tiles=None,\n    m=m,\n    marker_type=\"marker\",\n    marker_kwds={\"icon\": folium.Icon(color=\"red\", icon=\"star\")},\n    tooltip=[\"Name\"],   \n    popup=[\"Name\"],  \n)\n\n# Simple shelter legend (red star)\nlegend_html = \"\"\"\n&lt;div style=\"\n position: fixed; \n bottom: 50px; left: 50px; width: 160px; height: 40px; \n background: white; border:2px solid #444; z-index:9999; font-size:14px;\n padding:6px;\"&gt;\n&lt;b&gt;Legend&lt;/b&gt;&lt;br&gt;\n&lt;span style='color:red;'&gt;&#9733;&lt;/span&gt; Shelter\n&lt;/div&gt;\n\"\"\"\nm.get_root().html.add_child(folium.Element(legend_html))\n\nfolium.LayerControl().add_to(m)\n\nm\n\n\n\n  \n  \n  \n    Figure 2: Community Flood Risk Interactive Map",
    "crumbs": [
      "Results: Risk Management",
      "Community Flood Risk Map"
    ]
  },
  {
    "objectID": "analysis/4-folium.html",
    "href": "analysis/4-folium.html",
    "title": "Interactive Maps with Folium",
    "section": "",
    "text": "This page is generated from a Jupyter notebook and shows examples of embedding interactive maps produced using Folium."
  },
  {
    "objectID": "analysis/4-folium.html#finding-the-shortest-route",
    "href": "analysis/4-folium.html#finding-the-shortest-route",
    "title": "Interactive Maps with Folium",
    "section": "Finding the shortest route",
    "text": "Finding the shortest route\nThis example finds the shortest route between the Art Musuem and the Liberty Bell using osmnx.\n\nimport osmnx as ox\n\nFirst, identify the lat/lng coordinates for our places of interest. Use osmnx to download the geometries for the Libery Bell and Art Museum.\n\nphilly_tourism = ox.features_from_place(\"Philadelphia, PA\", tags={\"tourism\": True})\n\n\nart_museum = philly_tourism.query(\"name == 'Philadelphia Museum of Art'\").squeeze()\n\nart_museum.geometry\n\n\n\n\n\n\n\n\n\nliberty_bell = philly_tourism.query(\"name == 'Liberty Bell'\").squeeze()\n\nliberty_bell.geometry\n\n\n\n\n\n\n\n\nNow, extract the lat and lng coordinates\nFor the Art Museum geometry, we can use the .geometry.centroid attribute to calculate the centroid of the building footprint.\n\nliberty_bell_x = liberty_bell.geometry.x\nliberty_bell_y = liberty_bell.geometry.y\n\n\nart_museum_x = art_museum.geometry.centroid.x\nart_museum_y = art_museum.geometry.centroid.y\n\nNext, use osmnx to download the street graph around Center City.\n\nG_cc = ox.graph_from_address(\n    \"City Hall, Philadelphia, USA\", dist=1500, network_type=\"drive\"\n)\n\nNext, identify the nodes in the graph closest to our points of interest.\n\n# Get the origin node (Liberty Bell)\norig_node = ox.nearest_nodes(G_cc, liberty_bell_x, liberty_bell_y)\n\n# Get the destination node (Art Musuem)\ndest_node = ox.nearest_nodes(G_cc, art_museum_x, art_museum_y)\n\nFind the shortest path, based on the distance of the edges:\n\n# Get the shortest path --&gt; just a list of node IDs\nroute = ox.shortest_path(G_cc, orig_node, dest_node, weight=\"length\")\n\nHow about an interactive version?\nosmnx has a helper function ox.utils_graph.route_to_gdf() to convert a route to a GeoDataFrame of edges.\n\nox.utils_graph.route_to_gdf(G_cc, route, weight=\"length\").explore(\n    tiles=\"cartodb positron\",\n    color=\"red\",\n)\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "analysis/4-folium.html#examining-trash-related-311-requests",
    "href": "analysis/4-folium.html#examining-trash-related-311-requests",
    "title": "Interactive Maps with Folium",
    "section": "Examining Trash-Related 311 Requests",
    "text": "Examining Trash-Related 311 Requests\nFirst, let’s load the dataset from a CSV file and convert to a GeoDataFrame:\n\n\nCode\n# Load the data from a CSV file into a pandas DataFrame\ntrash_requests_df = pd.read_csv(\n    \"https://raw.githubusercontent.com/MUSA-550-Fall-2023/week-4/main/data/trash_311_requests_2020.csv\"\n)\n\n# Remove rows with missing geometry\ntrash_requests_df = trash_requests_df.dropna(subset=[\"lat\", \"lon\"])\n\n\n# Create our GeoDataFrame with geometry column created from lon/lat\ntrash_requests = gpd.GeoDataFrame(\n    trash_requests_df,\n    geometry=gpd.points_from_xy(trash_requests_df[\"lon\"], trash_requests_df[\"lat\"]),\n    crs=\"EPSG:4326\",\n)\n\n\nLoad neighborhoods and do the spatial join to associate a neighborhood with each ticket:\n\n\nCode\n# Load the neighborhoods\nneighborhoods = gpd.read_file(\n    \"https://raw.githubusercontent.com/MUSA-550-Fall-2023/week-4/main/data/zillow_neighborhoods.geojson\"\n)\n\n# Do the spatial join to add the \"ZillowName\" column\nrequests_with_hood = gpd.sjoin(\n    trash_requests,\n    neighborhoods.to_crs(trash_requests.crs),\n    predicate=\"within\",\n)\n\n\nLet’s explore the 311 requests in the Greenwich neighborhood of the city:\n\n# Extract out the point tickets for Greenwich\ngreenwich_tickets = requests_with_hood.query(\"ZillowName == 'Greenwich'\")\n\n\n# Get the neighborhood boundary for Greenwich\ngreenwich_geo = neighborhoods.query(\"ZillowName == 'Greenwich'\")\n\ngreenwich_geo.squeeze().geometry\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nQuarto has callout blocks that you can use to emphasize content in different ways. This is a “Note” callout block. More info is available on the Quarto documentation.\n\n\nImport the packages we need:\n\nimport folium\nimport xyzservices\n\nCombine the tickets as markers and the neighborhood boundary on the same Folium map:\n\n# Plot the neighborhood boundary\nm = greenwich_geo.explore(\n    style_kwds={\"weight\": 4, \"color\": \"black\", \"fillColor\": \"none\"},\n    name=\"Neighborhood boundary\",\n    tiles=xyzservices.providers.CartoDB.Voyager,\n)\n\n\n# Add the individual tickets as circle markers and style them\ngreenwich_tickets.explore(\n    m=m,  # Add to the existing map!\n    marker_kwds={\"radius\": 7, \"fill\": True, \"color\": \"crimson\"},\n    marker_type=\"circle_marker\", # or 'marker' or 'circle'\n    name=\"Tickets\",\n)\n\n# Hse folium to add layer control\nfolium.LayerControl().add_to(m)\n\nm  # show map\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  },
  {
    "objectID": "analysis/2-static-images.html",
    "href": "analysis/2-static-images.html",
    "title": "Showing static visualizations",
    "section": "",
    "text": "This page is generated from a Jupyter notebook and demonstrates how to generate static visualizations with matplotlib, pandas, and seaborn.\nStart by importing the packages we need:\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nLoad the “Palmer penguins” dataset from week 2:\n# Load data on Palmer penguins\npenguins = pd.read_csv(\"https://raw.githubusercontent.com/MUSA-550-Fall-2023/week-2/main/data/penguins.csv\")\n# Show the first ten rows\npenguins.head(n=10)    \n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\n\n\n\n\n0\nAdelie\nTorgersen\n39.1\n18.7\n181.0\n3750.0\nmale\n2007\n\n\n1\nAdelie\nTorgersen\n39.5\n17.4\n186.0\n3800.0\nfemale\n2007\n\n\n2\nAdelie\nTorgersen\n40.3\n18.0\n195.0\n3250.0\nfemale\n2007\n\n\n3\nAdelie\nTorgersen\nNaN\nNaN\nNaN\nNaN\nNaN\n2007\n\n\n4\nAdelie\nTorgersen\n36.7\n19.3\n193.0\n3450.0\nfemale\n2007\n\n\n5\nAdelie\nTorgersen\n39.3\n20.6\n190.0\n3650.0\nmale\n2007\n\n\n6\nAdelie\nTorgersen\n38.9\n17.8\n181.0\n3625.0\nfemale\n2007\n\n\n7\nAdelie\nTorgersen\n39.2\n19.6\n195.0\n4675.0\nmale\n2007\n\n\n8\nAdelie\nTorgersen\n34.1\n18.1\n193.0\n3475.0\nNaN\n2007\n\n\n9\nAdelie\nTorgersen\n42.0\n20.2\n190.0\n4250.0\nNaN\n2007"
  },
  {
    "objectID": "analysis/2-static-images.html#a-simple-visualization-3-different-ways",
    "href": "analysis/2-static-images.html#a-simple-visualization-3-different-ways",
    "title": "Showing static visualizations",
    "section": "A simple visualization, 3 different ways",
    "text": "A simple visualization, 3 different ways\n\nI want to scatter flipper length vs. bill length, colored by the penguin species\n\n\nUsing matplotlib\n\n# Setup a dict to hold colors for each species\ncolor_map = {\"Adelie\": \"#1f77b4\", \"Gentoo\": \"#ff7f0e\", \"Chinstrap\": \"#D62728\"}\n\n# Initialize the figure \"fig\" and axes \"ax\"\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# Group the data frame by species and loop over each group\n# NOTE: \"group\" will be the dataframe holding the data for \"species\"\nfor species, group_df in penguins.groupby(\"species\"):\n\n    # Plot flipper length vs bill length for this group\n    # Note: we are adding this plot to the existing \"ax\" object\n    ax.scatter(\n        group_df[\"flipper_length_mm\"],\n        group_df[\"bill_length_mm\"],\n        marker=\"o\",\n        label=species,\n        color=color_map[species],\n        alpha=0.75,\n        zorder=10\n    )\n\n# Plotting is done...format the axes!\n\n## Add a legend to the axes\nax.legend(loc=\"best\")\n\n## Add x-axis and y-axis labels\nax.set_xlabel(\"Flipper Length (mm)\")\nax.set_ylabel(\"Bill Length (mm)\")\n\n## Add the grid of lines\nax.grid(True);\n\n\n\n\n\n\n\n\n\n\nHow about in pandas?\nDataFrames have a built-in “plot” function that can make all of the basic type of matplotlib plots!\nFirst, we need to add a new “color” column specifying the color to use for each species type.\nUse the pd.replace() function: it use a dict to replace values in a DataFrame column.\n\n# Calculate a list of colors\ncolor_map = {\"Adelie\": \"#1f77b4\", \"Gentoo\": \"#ff7f0e\", \"Chinstrap\": \"#D62728\"}\n\n# Map species name to color \npenguins[\"color\"] = penguins[\"species\"].replace(color_map)\n\npenguins.head()\n\n\n\n\n\n\n\n\nspecies\nisland\nbill_length_mm\nbill_depth_mm\nflipper_length_mm\nbody_mass_g\nsex\nyear\ncolor\n\n\n\n\n0\nAdelie\nTorgersen\n39.1\n18.7\n181.0\n3750.0\nmale\n2007\n#1f77b4\n\n\n1\nAdelie\nTorgersen\n39.5\n17.4\n186.0\n3800.0\nfemale\n2007\n#1f77b4\n\n\n2\nAdelie\nTorgersen\n40.3\n18.0\n195.0\n3250.0\nfemale\n2007\n#1f77b4\n\n\n3\nAdelie\nTorgersen\nNaN\nNaN\nNaN\nNaN\nNaN\n2007\n#1f77b4\n\n\n4\nAdelie\nTorgersen\n36.7\n19.3\n193.0\n3450.0\nfemale\n2007\n#1f77b4\n\n\n\n\n\n\n\nNow plot!\n\n# Same as before: Start by initializing the figure and axes\nfig, myAxes = plt.subplots(figsize=(10, 6))\n\n# Scatter plot two columns, colored by third\n# Use the built-in pandas plot.scatter function\npenguins.plot.scatter(\n    x=\"flipper_length_mm\",\n    y=\"bill_length_mm\",\n    c=\"color\",\n    alpha=0.75,\n    ax=myAxes, # IMPORTANT: Make sure to plot on the axes object we created already!\n    zorder=10\n)\n\n# Format the axes finally\nmyAxes.set_xlabel(\"Flipper Length (mm)\")\nmyAxes.set_ylabel(\"Bill Length (mm)\")\nmyAxes.grid(True);\n\n\n\n\n\n\n\n\nNote: no easy way to get legend added to the plot in this case…\n\n\nSeaborn: statistical data visualization\nSeaborn is designed to plot two columns colored by a third column…\n\n# Initialize the figure and axes\nfig, ax = plt.subplots(figsize=(10, 6))\n\n# style keywords as dict\ncolor_map = {\"Adelie\": \"#1f77b4\", \"Gentoo\": \"#ff7f0e\", \"Chinstrap\": \"#D62728\"}\nstyle = dict(palette=color_map, s=60, edgecolor=\"none\", alpha=0.75, zorder=10)\n\n# use the scatterplot() function\nsns.scatterplot(\n    x=\"flipper_length_mm\",  # the x column\n    y=\"bill_length_mm\",  # the y column\n    hue=\"species\",  # the third dimension (color)\n    data=penguins,  # pass in the data\n    ax=ax,  # plot on the axes object we made\n    **style  # add our style keywords\n)\n\n# Format with matplotlib commands\nax.set_xlabel(\"Flipper Length (mm)\")\nax.set_ylabel(\"Bill Length (mm)\")\nax.grid(True)\nax.legend(loc=\"best\");"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me",
    "section": "",
    "text": "Master’s Student in City & Regional Planning\n\n\nUniversity of Pennsylvania\n\n\nI’m from Beijing, China. I completed my undergraduate degree in Urban Planning at Tongji University with a focus on Urban Design. I enjoy drawing, playing tennis and travelling. I’m passionate about cities, spatial design, and how planning can make urban life more livable.\n\n\nWith experience across Python, ArcGIS, and urban design tools, I enjoy combining data and design to tell spatial stories. If you would like to see more of my work, here is my portfolio.",
    "crumbs": [
      "About Me"
    ]
  },
  {
    "objectID": "about.html#hi-im-yanru-fang",
    "href": "about.html#hi-im-yanru-fang",
    "title": "About Me",
    "section": "",
    "text": "Master’s Student in City & Regional Planning\n\n\nUniversity of Pennsylvania\n\n\nI’m from Beijing, China. I completed my undergraduate degree in Urban Planning at Tongji University with a focus on Urban Design. I enjoy drawing, playing tennis and travelling. I’m passionate about cities, spatial design, and how planning can make urban life more livable.\n\n\nWith experience across Python, ArcGIS, and urban design tools, I enjoy combining data and design to tell spatial stories. If you would like to see more of my work, here is my portfolio.",
    "crumbs": [
      "About Me"
    ]
  },
  {
    "objectID": "analysis/1-python-code-blocks.html",
    "href": "analysis/1-python-code-blocks.html",
    "title": "Python code blocks",
    "section": "",
    "text": "This is an example from the Quarto documentation that shows how to mix executable Python code blocks into a markdown file in a “Quarto markdown” .qmd file.\nFor a demonstration of a line plot on a polar axis, see Figure 1.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1: A line plot on a polar axis"
  },
  {
    "objectID": "analysis/3-altair-hvplot.html",
    "href": "analysis/3-altair-hvplot.html",
    "title": "Altair and Hvplot Charts",
    "section": "",
    "text": "This page is generated from a Jupyter notebook and shows examples of embedding interactive charts produced using Altair and hvPlot."
  },
  {
    "objectID": "analysis/3-altair-hvplot.html#example-measles-incidence-in-altair",
    "href": "analysis/3-altair-hvplot.html#example-measles-incidence-in-altair",
    "title": "Altair and Hvplot Charts",
    "section": "Example: Measles Incidence in Altair",
    "text": "Example: Measles Incidence in Altair\nFirst, let’s load the data for measles incidence in wide format:\n\n\nCode\nurl = \"https://raw.githubusercontent.com/MUSA-550-Fall-2023/week-2/main/data/measles_incidence.csv\"\ndata = pd.read_csv(url, skiprows=2, na_values=\"-\")\n\n\n\n\n\n\n\n\n\n\n\nYEAR\nWEEK\nALABAMA\nALASKA\nARIZONA\nARKANSAS\nCALIFORNIA\nCOLORADO\nCONNECTICUT\nDELAWARE\n...\nSOUTH DAKOTA\nTENNESSEE\nTEXAS\nUTAH\nVERMONT\nVIRGINIA\nWASHINGTON\nWEST VIRGINIA\nWISCONSIN\nWYOMING\n\n\n\n\n0\n1928\n1\n3.67\nNaN\n1.90\n4.11\n1.38\n8.38\n4.50\n8.58\n...\n5.69\n22.03\n1.18\n0.4\n0.28\nNaN\n14.83\n3.36\n1.54\n0.91\n\n\n1\n1928\n2\n6.25\nNaN\n6.40\n9.91\n1.80\n6.02\n9.00\n7.30\n...\n6.57\n16.96\n0.63\nNaN\n0.56\nNaN\n17.34\n4.19\n0.96\nNaN\n\n\n2\n1928\n3\n7.95\nNaN\n4.50\n11.15\n1.31\n2.86\n8.81\n15.88\n...\n2.04\n24.66\n0.62\n0.2\n1.12\nNaN\n15.67\n4.19\n4.79\n1.36\n\n\n3\n1928\n4\n12.58\nNaN\n1.90\n13.75\n1.87\n13.71\n10.40\n4.29\n...\n2.19\n18.86\n0.37\n0.2\n6.70\nNaN\n12.77\n4.66\n1.64\n3.64\n\n\n4\n1928\n5\n8.03\nNaN\n0.47\n20.79\n2.38\n5.13\n16.80\n5.58\n...\n3.94\n20.05\n1.57\n0.4\n6.70\nNaN\n18.83\n7.37\n2.91\n0.91\n\n\n\n\n5 rows × 53 columns\n\n\n\nThen, use the pandas.melt() function to convert it to tidy format:\n\n\nCode\nannual = data.drop(\"WEEK\", axis=1)\nmeasles = annual.groupby(\"YEAR\").sum().reset_index()\nmeasles = measles.melt(id_vars=\"YEAR\", var_name=\"state\", value_name=\"incidence\")\n\n\n\n\n\n\n\n\n\n\n\nYEAR\nstate\nincidence\n\n\n\n\n0\n1928\nALABAMA\n334.99\n\n\n1\n1929\nALABAMA\n111.93\n\n\n2\n1930\nALABAMA\n157.00\n\n\n3\n1931\nALABAMA\n337.29\n\n\n4\n1932\nALABAMA\n10.21\n\n\n\n\n\n\n\nFinally, load altair:\n\nimport altair as alt\n\nAnd generate our final data viz:\n\n# use a custom color map\ncolormap = alt.Scale(\n    domain=[0, 100, 200, 300, 1000, 3000],\n    range=[\n        \"#F0F8FF\",\n        \"cornflowerblue\",\n        \"mediumseagreen\",\n        \"#FFEE00\",\n        \"darkorange\",\n        \"firebrick\",\n    ],\n    type=\"sqrt\",\n)\n\n# Vertical line for vaccination year\nthreshold = pd.DataFrame([{\"threshold\": 1963}])\n\n# plot YEAR vs state, colored by incidence\nchart = (\n    alt.Chart(measles)\n    .mark_rect()\n    .encode(\n        x=alt.X(\"YEAR:O\", axis=alt.Axis(title=None, ticks=False)),\n        y=alt.Y(\"state:N\", axis=alt.Axis(title=None, ticks=False)),\n        color=alt.Color(\"incidence:Q\", sort=\"ascending\", scale=colormap, legend=None),\n        tooltip=[\"state\", \"YEAR\", \"incidence\"],\n    )\n    .properties(width=650, height=500)\n)\n\nrule = alt.Chart(threshold).mark_rule(strokeWidth=4).encode(x=\"threshold:O\")\n\nout = chart + rule\nout"
  },
  {
    "objectID": "analysis/3-altair-hvplot.html#example-measles-incidence-in-hvplot",
    "href": "analysis/3-altair-hvplot.html#example-measles-incidence-in-hvplot",
    "title": "Altair and Hvplot Charts",
    "section": "Example: Measles Incidence in hvplot",
    "text": "Example: Measles Incidence in hvplot\n\n\n\n\n\n\n\n\n\n\n\nGenerate the same data viz in hvplot:\n\n# Make the heatmap with hvplot\nheatmap = measles.hvplot.heatmap(\n    x=\"YEAR\",\n    y=\"state\",\n    C=\"incidence\", # color each square by the incidence\n    reduce_function=np.sum, # sum the incidence for each state/year\n    frame_height=450,\n    frame_width=600,\n    flip_yaxis=True,\n    rot=90,\n    colorbar=False,\n    cmap=\"viridis\",\n    xlabel=\"\",\n    ylabel=\"\",\n)\n\n# Some additional formatting using holoviews \n# For more info: http://holoviews.org/user_guide/Customizing_Plots.html\nheatmap = heatmap.redim(state=\"State\", YEAR=\"Year\")\nheatmap = heatmap.opts(fontsize={\"xticks\": 0, \"yticks\": 6}, toolbar=\"above\")\nheatmap"
  },
  {
    "objectID": "analysis/index.html",
    "href": "analysis/index.html",
    "title": "Analysis",
    "section": "",
    "text": "Analysis\nThis section includes examples of technical analysis done using Jupyter notebooks. Each sub-section highlights different types of analyses and visualizations. In particular, it highlights that we can easily publish interactive visualizations produced with packages such as hvPlot, altair, or Folium, without losing any of the interactive features.\nOn this page, you might want to share more introductory or background information about the analyses to help guide the reader."
  },
  {
    "objectID": "conclusion.html",
    "href": "conclusion.html",
    "title": "Discussions",
    "section": "",
    "text": "Overall, this study demonstrates that flood susceptibility in St. Thomas is primarily driven by terrain-related factors such as elevation, slope, proximity to ghuts, and exposure to coastal hazards. These variables remained consistently important across model configurations, underscoring the dominant influence of topography and drainage pathways on small-island flooding dynamics. The integration of shelter-accessibility analysis reveals additional disparities: several residential communities face long walking distances to designated shelters. Notably, some lower-value housing communities experience a double burden—higher modeled flood susceptibility combined with reduced evacuation accessibility—highlighting uneven spatial distribution of both hazard and protective infrastructure.",
    "crumbs": [
      "Discussions"
    ]
  },
  {
    "objectID": "conclusion.html#conclusion-and-key-insights",
    "href": "conclusion.html#conclusion-and-key-insights",
    "title": "Discussions",
    "section": "",
    "text": "Overall, this study demonstrates that flood susceptibility in St. Thomas is primarily driven by terrain-related factors such as elevation, slope, proximity to ghuts, and exposure to coastal hazards. These variables remained consistently important across model configurations, underscoring the dominant influence of topography and drainage pathways on small-island flooding dynamics. The integration of shelter-accessibility analysis reveals additional disparities: several residential communities face long walking distances to designated shelters. Notably, some lower-value housing communities experience a double burden—higher modeled flood susceptibility combined with reduced evacuation accessibility—highlighting uneven spatial distribution of both hazard and protective infrastructure.",
    "crumbs": [
      "Discussions"
    ]
  },
  {
    "objectID": "conclusion.html#limitations",
    "href": "conclusion.html#limitations",
    "title": "Discussions",
    "section": "Limitations",
    "text": "Limitations\nDespite its contributions, the study faces several methodological limitations. First, the feature set excludes potentially influential factors such as soil permeability, local drainage infrastructure, and building elevation or structural quality. Their absence may reduce model realism and could also interact with Random Forest behavior, where binary indicator variables (e.g., land-cover dummy variables) sometimes inflate variable importance or increase the risk of overfitting due to repeated splitting on sparse categorical features—an issue noted in machine learning literature concerning tree-based models’ handling of high-dimensional, low-information predictors.\nSecond, the exposure-disparity assessment is descriptive rather than inferential. Expanding future analyses with spatial statistical techniques, such as clustering indices, geographically weighted accessibility, or income-weighted exposure metrics, would enable a more rigorous understanding of inequities across neighborhoods.\nThird, the shelter-accessibility analysis assumes fully walkable and unobstructed routes. In practice, steep slopes, damaged road segments, or high-flow crossings during storm events may affect real evacuation ability. Future work could incorporate slope-adjusted travel times, network impedance under hazard conditions, or blocked-road scenarios to produce more realistic accessibility estimates.\nTaken together, these findings underscore the importance of integrating geophysical factors with social and infrastructural dimensions to support more equitable flood-risk management and resilience planning in St. Thomas.",
    "crumbs": [
      "Discussions"
    ]
  },
  {
    "objectID": "flood-susceptibility.html",
    "href": "flood-susceptibility.html",
    "title": "Flood Susceptibility",
    "section": "",
    "text": "The Random Forest (RF) model was adopted to map flood susceptibility across St. Thomas. The training data, consisting of 14 flood-conditioning features, was standardized through a pipeline and input into an RF classifier, with its performance first assessed using a held-out test set. To improve stability and reduce overfitting, model performance was further evaluated through 5-fold stratified cross-validation using ROC–AUC as the scoring metric. A GridSearchCV procedure was implemented to optimize hyperparameters across a search space including the number of trees (50–150), maximum depth (8–None), and minimum samples required for node splits and leaf nodes. The best-performing configuration—identified through cross-validated AUC—included 100 trees, a maximum depth of 10, a minimum of 5 samples to split a node, and 3 samples per leaf, with class weights balanced to address sample imbalance.\nUsing this optimized model, the RF classifier achieved strong predictive performance (accuracy = 0.85; AUC = 0.94). Class-level precision, recall, and F1 scores remained consistently high for both flooded and non-flooded samples, ranging from 0.82 to 0.88. The ROC curve demonstrates robust discrimination across false-positive rates, confirming the model’s reliability. Feature importance rankings indicate that elevation is the dominant predictor, followed by slope, distance to ghuts, tsunami exposure, and forest cover, while remaining land-cover classes contribute smaller but meaningful signals.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport numpy as np\nfrom pathlib import Path\nimport geopandas as gpd\n\ny_pred = best_model.predict(X_test)\ny_proba = best_model.predict_proba(X_test)[:, 1]\n\nfpr, tpr, thr = roc_curve(y_test, y_proba)\n\nplt.figure(figsize=(6, 5))\nplt.plot(fpr, tpr, label=f\"AUC = {roc_auc_score(y_test, y_proba):.3f}\")\nplt.plot([0, 1], [0, 1], \"k--\")\nplt.xlabel(\"False Positive Rate\")\nplt.ylabel(\"True Positive Rate\")\nplt.legend()\nplt.show()\n\n\n\n\n\nFigure 1: ROC – Flood Susceptibility Model\n\n\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport numpy as np\nfrom pathlib import Path\nimport geopandas as gpd\n\nrf_model = best_model.named_steps[\"randomforestclassifier\"]\nimportance = pd.DataFrame({\n    \"Feature\": feature_cols,\n    \"Importance\": rf_model.feature_importances_\n}).sort_values(\"Importance\", ascending=False)\n\n# Create chart\nimportance = pd.DataFrame({\n    \"Feature\": feature_cols,\n    \"Importance\": rf_model.feature_importances_\n}).sort_values(\"Importance\", ascending=False)\n\nax = importance.sort_values(\"Importance\", ascending=True).plot.barh(\n    x=\"Feature\",\n    y=\"Importance\",\n    figsize=(6, 8),\n    legend=False  # no legend by default\n)\n\n# Increase font sizes\nax.set_xlabel(\"Importance\", fontsize=12)\nax.set_ylabel(\"Feature\", fontsize=12)\nax.tick_params(axis=\"both\", labelsize=11)\n\nplt.show()\n\n\n\n\n\nFigure 2: Feature Importance",
    "crumbs": [
      "Methods and Analysis",
      "Flood Susceptibility"
    ]
  },
  {
    "objectID": "flood-susceptibility.html#the-random-forest-model",
    "href": "flood-susceptibility.html#the-random-forest-model",
    "title": "Flood Susceptibility",
    "section": "",
    "text": "The Random Forest (RF) model was adopted to map flood susceptibility across St. Thomas. The training data, consisting of 14 flood-conditioning features, was standardized through a pipeline and input into an RF classifier, with its performance first assessed using a held-out test set. To improve stability and reduce overfitting, model performance was further evaluated through 5-fold stratified cross-validation using ROC–AUC as the scoring metric. A GridSearchCV procedure was implemented to optimize hyperparameters across a search space including the number of trees (50–150), maximum depth (8–None), and minimum samples required for node splits and leaf nodes. The best-performing configuration—identified through cross-validated AUC—included 100 trees, a maximum depth of 10, a minimum of 5 samples to split a node, and 3 samples per leaf, with class weights balanced to address sample imbalance.\nUsing this optimized model, the RF classifier achieved strong predictive performance (accuracy = 0.85; AUC = 0.94). Class-level precision, recall, and F1 scores remained consistently high for both flooded and non-flooded samples, ranging from 0.82 to 0.88. The ROC curve demonstrates robust discrimination across false-positive rates, confirming the model’s reliability. Feature importance rankings indicate that elevation is the dominant predictor, followed by slope, distance to ghuts, tsunami exposure, and forest cover, while remaining land-cover classes contribute smaller but meaningful signals.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport numpy as np\nfrom pathlib import Path\nimport geopandas as gpd\n\ny_pred = best_model.predict(X_test)\ny_proba = best_model.predict_proba(X_test)[:, 1]\n\nfpr, tpr, thr = roc_curve(y_test, y_proba)\n\nplt.figure(figsize=(6, 5))\nplt.plot(fpr, tpr, label=f\"AUC = {roc_auc_score(y_test, y_proba):.3f}\")\nplt.plot([0, 1], [0, 1], \"k--\")\nplt.xlabel(\"False Positive Rate\")\nplt.ylabel(\"True Positive Rate\")\nplt.legend()\nplt.show()\n\n\n\n\n\nFigure 1: ROC – Flood Susceptibility Model\n\n\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport numpy as np\nfrom pathlib import Path\nimport geopandas as gpd\n\nrf_model = best_model.named_steps[\"randomforestclassifier\"]\nimportance = pd.DataFrame({\n    \"Feature\": feature_cols,\n    \"Importance\": rf_model.feature_importances_\n}).sort_values(\"Importance\", ascending=False)\n\n# Create chart\nimportance = pd.DataFrame({\n    \"Feature\": feature_cols,\n    \"Importance\": rf_model.feature_importances_\n}).sort_values(\"Importance\", ascending=False)\n\nax = importance.sort_values(\"Importance\", ascending=True).plot.barh(\n    x=\"Feature\",\n    y=\"Importance\",\n    figsize=(6, 8),\n    legend=False  # no legend by default\n)\n\n# Increase font sizes\nax.set_xlabel(\"Importance\", fontsize=12)\nax.set_ylabel(\"Feature\", fontsize=12)\nax.tick_params(axis=\"both\", labelsize=11)\n\nplt.show()\n\n\n\n\n\nFigure 2: Feature Importance",
    "crumbs": [
      "Methods and Analysis",
      "Flood Susceptibility"
    ]
  },
  {
    "objectID": "flood-susceptibility.html#the-flood-susceptibility",
    "href": "flood-susceptibility.html#the-flood-susceptibility",
    "title": "Flood Susceptibility",
    "section": "The Flood Susceptibility",
    "text": "The Flood Susceptibility\nWith the model validated, the trained RF classifier was applied to the full study area to generate a spatially continuous flood susceptibility map. The flood susceptibility in St Thomas shows a 100 m × 100 m flood susceptibility index ranging from 0.0 (purple, very low) to 1.0 (bright yellow, very high). Values above ~0.8 are concentrated along the coastal fringe, harbors, and embayed shorelines, indicating the most exposed zones. Mid-range values (~0.4–0.7) extend inland along primary drainage corridors. Interior uplands and ridges are dominated by low indices (&lt;0.3), reflecting reduced ponding potential at higher elevations.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Mask NaNs\nsuscept_masked = np.ma.masked_invalid(suscept_arr)\n\nfig, ax = plt.subplots(figsize=(10, 4))\n\n# Dark purple background\nfig.patch.set_facecolor(\"#2b005a\")\nax.set_facecolor(\"#2b005a\")\n\nimg = ax.imshow(\n    suscept_masked,\n    extent=(minx, maxx, miny, maxy),\n    origin=\"upper\",\n    cmap=\"viridis\",\n    vmin=0,\n    vmax=1,\n    interpolation=\"nearest\",\n)\n\n# Optional boundary overlay\nboundary.boundary.plot(ax=ax, color=\"white\", linewidth=1)\n\n# Horizontal colorbar inset (bottom-left)\ncax = ax.inset_axes([0.05, 0.08, 0.25, 0.06])  # [x, y, width, height] in axis fraction\ncbar = fig.colorbar(img, cax=cax, orientation=\"horizontal\")\ncbar.ax.set_title(\"IF (%)\", fontsize=9, pad=4, color=\"white\")\ncbar.outline.set_linewidth(0)\ncbar.ax.tick_params(size=0)\ncbar.ax.xaxis.set_tick_params(pad=4, colors=\"white\")\n\nax.set_axis_off()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nFigure 3: Flood Susceptibility in St Thomas",
    "crumbs": [
      "Methods and Analysis",
      "Flood Susceptibility"
    ]
  },
  {
    "objectID": "notebook.html",
    "href": "notebook.html",
    "title": "Explore_Floodrisk",
    "section": "",
    "text": "import folium\nimport geopandas as gpd\n\n\n# Load boundary in WGS84\nboundary = gpd.read_file(\"data/processed/st_thomas_boundary.geojson\").to_crs(\"EPSG:4326\")\n\n# Project to a planar CRS (UTM zone 20N) to compute centroid accurately\nboundary_proj = boundary.to_crs(epsg=32620)\nctr_proj = boundary_proj.geometry.centroid\n\n# Transform centroid back to WGS84 for map center\nctr_wgs = gpd.GeoSeries(ctr_proj, crs=32620).to_crs(epsg=4326)\ncenter_lat = ctr_wgs.y.mean()\ncenter_lon = ctr_wgs.x.mean()\n\n# Build the Folium map\nf = folium.Figure(height=500)\nm = folium.Map(location=[center_lat, center_lon], zoom_start=12, control_scale=True).add_to(f)\n\n# Esri Satellite basemap\nfolium.TileLayer(\n    tiles='https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n    attr='Esri',\n    name='Esri Satellite',\n    overlay=False,\n    control=True\n).add_to(m)\n\n# Boundary overlay\nfolium.GeoJson(\n    boundary.to_json(),\n    name=\"Boundary\",\n    style_function=lambda x: {\"color\": \"#DD6F78\", \"weight\": 2, \"fill\": False},\n).add_to(m)\n\n# Layer control\nfolium.LayerControl().add_to(m)\n\n# Display \nm\nm.save(\"vis/stthomas.html\")\n\n\n!pip install osmnx\n\nimport osmnx as ox\nimport geopandas as gpd\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n\n# Robust make_valid import\ntry:\n    from shapely import make_valid\nexcept ImportError:\n    make_valid = lambda geom: geom.buffer(0)\n\n# Paths and CRS\ndata_dir = Path(\"data\")\nprocessed = data_dir / \"processed\"\nprocessed.mkdir(exist_ok=True)\ntarget_crs = \"EPSG:3857\"\n\nRequirement already satisfied: osmnx in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (1.6.0)\nRequirement already satisfied: geopandas&gt;=0.12 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from osmnx) (0.13.2)\nRequirement already satisfied: networkx&gt;=2.5 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from osmnx) (3.1)\nRequirement already satisfied: numpy&gt;=1.20 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from osmnx) (1.24.4)\nRequirement already satisfied: pandas&gt;=1.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from osmnx) (1.5.3)\nRequirement already satisfied: requests&gt;=2.27 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from osmnx) (2.31.0)\nRequirement already satisfied: shapely&gt;=2.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from osmnx) (2.0.1)\nRequirement already satisfied: fiona&gt;=1.8.19 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from geopandas&gt;=0.12-&gt;osmnx) (1.9.4)\nRequirement already satisfied: packaging in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from geopandas&gt;=0.12-&gt;osmnx) (25.0)\nRequirement already satisfied: pyproj&gt;=3.0.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from geopandas&gt;=0.12-&gt;osmnx) (3.6.1)\nRequirement already satisfied: python-dateutil&gt;=2.8.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from pandas&gt;=1.1-&gt;osmnx) (2.9.0.post0)\nRequirement already satisfied: pytz&gt;=2020.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from pandas&gt;=1.1-&gt;osmnx) (2025.2)\nRequirement already satisfied: charset-normalizer&lt;4,&gt;=2 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests&gt;=2.27-&gt;osmnx) (3.4.3)\nRequirement already satisfied: idna&lt;4,&gt;=2.5 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests&gt;=2.27-&gt;osmnx) (3.10)\nRequirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests&gt;=2.27-&gt;osmnx) (1.26.19)\nRequirement already satisfied: certifi&gt;=2017.4.17 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from requests&gt;=2.27-&gt;osmnx) (2025.11.12)\nRequirement already satisfied: attrs&gt;=19.2.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from fiona&gt;=1.8.19-&gt;geopandas&gt;=0.12-&gt;osmnx) (25.3.0)\nRequirement already satisfied: click~=8.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from fiona&gt;=1.8.19-&gt;geopandas&gt;=0.12-&gt;osmnx) (8.2.1)\nRequirement already satisfied: click-plugins&gt;=1.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from fiona&gt;=1.8.19-&gt;geopandas&gt;=0.12-&gt;osmnx) (1.1.1.2)\nRequirement already satisfied: cligj&gt;=0.5 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from fiona&gt;=1.8.19-&gt;geopandas&gt;=0.12-&gt;osmnx) (0.7.2)\nRequirement already satisfied: six in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from fiona&gt;=1.8.19-&gt;geopandas&gt;=0.12-&gt;osmnx) (1.17.0)\nRequirement already satisfied: colorama in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from click~=8.0-&gt;fiona&gt;=1.8.19-&gt;geopandas&gt;=0.12-&gt;osmnx) (0.4.6)\n\n\n\n# Try a few common place strings for St. Thomas\nplace_candidates = [\n    \"St. Thomas, U.S. Virgin Islands\",\n    \"Saint Thomas, U.S. Virgin Islands\",\n    \"St Thomas, U.S. Virgin Islands\",\n]\n\nboundary = None\nlast_err = None\nfor place in place_candidates:\n    try:\n        gdf = ox.geocode_to_gdf(place)\n        if not gdf.empty:\n            gdf[\"query\"] = place\n            boundary = gdf\n            break\n    except Exception as e:\n        last_err = e\n\nif boundary is None:\n    raise RuntimeError(f\"Failed to fetch boundary. Last error: {last_err}\")\n\n# Inspect CRS and basic info\nprint(\"Original CRS:\", boundary.crs)\ndisplay(boundary.head())\n\n# Project to Web Mercator (EPSG:3857)\nboundary_3857 = boundary.to_crs(target_crs)\n\n# Plot projected boundary\nax = boundary_3857.plot(facecolor=\"none\", edgecolor=\"black\", figsize=(6, 6))\nax.set_title(\"St. Thomas Boundary (EPSG:3857)\")\nax.set_axis_off()\nplt.show()\n\n# Save to processed folder\nout_path = processed / \"st_thomas_boundary.geojson\"\nboundary_3857.to_file(out_path, driver=\"GeoJSON\")\nprint(\"Saved boundary to:\", out_path)\n\nOriginal CRS: epsg:4326\n\n\n\n\n\n\n\n\n\ngeometry\nbbox_north\nbbox_south\nbbox_east\nbbox_west\nplace_id\nosm_type\nosm_id\nlat\nlon\nclass\ntype\nplace_rank\nimportance\naddresstype\nname\ndisplay_name\nquery\n\n\n\n\n0\nPOLYGON ((-65.04213 18.35287, -65.04203 18.352...\n18.383334\n18.302428\n-64.831785\n-65.042129\n281792257\nrelation\n17825234\n18.342908\n-64.9189\nplace\nisland\n17\n0.54065\nisland\nSaint Thomas\nSaint Thomas, Charlotte Amalie, Saint Thomas -...\nSt. Thomas, U.S. Virgin Islands\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSaved boundary to: data\\processed\\st_thomas_boundary.geojson\n\n\n\nimport geopandas as gpd\nfrom shapely.validation import make_valid  \n\n# Load study area boundary and project to analysis CRS\nboundary_fp = processed / \"st_thomas_boundary.geojson\"\n\n# Read raw boundary \nboundary = gpd.read_file(boundary_fp)\n\n# Project to target_crs \nboundary = boundary.to_crs(target_crs)\n\n# Fix invalid geometries (self-intersections, slivers, etc.)\nboundary[\"geometry\"] = boundary.geometry.apply(make_valid)\n\n# Drop empty / null geometries\nboundary = boundary[\n    boundary.geometry.notnull() & ~boundary.geometry.is_empty\n]\n\n# Dissolve all parts into a single study-area polygon\nboundary[\"dissolve_id\"] = 1  # same value for all rows\nboundary_dissolved = boundary.dissolve(by=\"dissolve_id\")\n\n# Single Polygon (or MultiPolygon) object, useful for clip / Pandana bbox\nboundary_union = boundary_dissolved.geometry.iloc[0]\nboundary_single = gpd.GeoDataFrame(\n    geometry=[boundary_union],\n    crs=target_crs\n)\n\nprint(\"Boundary rows (raw):\", len(boundary))\nprint(\"Boundary union type:\", boundary_union.geom_type)\n\nBoundary rows (raw): 1\nBoundary union type: Polygon\n\n\n\nfrom shapely import make_valid\n\ndef safe_make_valid(geom):\n    if geom is None:\n        return None\n    try:\n        if geom.is_valid:\n            return geom\n        return make_valid(geom)\n    except Exception:\n        return None\n\n# Define layers to process: input filename -&gt; output filename\nlayers = {\n    \"USVI_Flood_Zone.geojson\": \"flood_zone_st_thomas_3857.gpkg\",\n    \"USVI_Tsunami.geojson\": \"tsunami_st_thomas_3857.gpkg\",\n    \"USVI_Ghuts.geojson\": \"ghuts_st_thomas_3857.gpkg\",\n    \"LandCover.geojson\": \"landcover_st_thomas_3857.gpkg\",\n    \"BuildingFootprints.geojson\": \"buildings_st_thomas_3857.gpkg\",\n    \"parcel_value.geojson\": \"parcel_value_st_thomas_3857.gpkg\",\n}\n\nsummary = {}\n\nfor fname, outname in layers.items():\n    fpath = data_dir / fname\n    gdf = gpd.read_file(fpath)\n\n    # If CRS missing, assume WGS84\n    if gdf.crs is None:\n        gdf = gdf.set_crs(\"EPSG:4326\")\n\n    # Reproject to target CRS\n    gdf = gdf.to_crs(target_crs)\n\n    # Drop null geometries, fix geometries, drop empties\n    gdf = gdf.dropna(subset=[\"geometry\"]).copy()\n    gdf[\"geometry\"] = gdf.geometry.apply(safe_make_valid)\n    gdf = gdf.dropna(subset=[\"geometry\"])\n    gdf = gdf[~gdf.geometry.is_empty]\n\n    # Clip to boundary\n    clipped = gdf.clip(boundary_union)\n    clipped = clipped[~clipped.geometry.is_empty]\n\n    # Save\n    out_path = processed / outname\n    clipped.to_file(out_path, driver=\"GPKG\")\n\n    # Record summary\n    summary[fname] = {\n        \"input_count\": len(gdf),\n        \"clipped_count\": len(clipped),\n        \"crs\": str(gdf.crs),\n        \"output\": str(out_path),\n        \"columns\": list(clipped.columns),\n    }\n\n    # Preview head and plot\n    print(f\"\\n=== {fname} ===\")\n    print(summary[fname])\n    display(clipped.head())\n\n    ax = clipped.plot(figsize=(6, 6), alpha=0.6, edgecolor=\"k\", linewidth=0.2)\n    boundary.boundary.plot(ax=ax, color=\"red\", linewidth=1)\n    ax.set_title(f\"{fname}\")\n    ax.set_axis_off()\n    plt.show()\n\nprint(\"\\nDone. Summary:\")\nfor k, v in summary.items():\n    print(k, v)\n\n\n=== USVI_Flood_Zone.geojson ===\n{'input_count': 2556, 'clipped_count': 499, 'crs': 'EPSG:3857', 'output': 'data\\\\processed\\\\flood_zone_st_thomas_3857.gpkg', 'columns': ['FID', 'FLD_ZONE', 'ST_BFE_ft', 'V_DATUM', 'FZn_ID', 'Depth_ft', 'ZONE_SUBTY', 'SHAPE_Leng', 'Shape__Are', 'Shape__Len', 'FldZone', 'SqMi', 'Shape__Area', 'Shape__Length', 'geometry']}\n\n\n\n\n\n\n\n\n\nFID\nFLD_ZONE\nST_BFE_ft\nV_DATUM\nFZn_ID\nDepth_ft\nZONE_SUBTY\nSHAPE_Leng\nShape__Are\nShape__Len\nFldZone\nSqMi\nShape__Area\nShape__Length\ngeometry\n\n\n\n\n670\n671\nVE\n13\nVIVD09\n715\n-9999\nNP\n2082.678017\n1.513524e-06\n0.005910\nVE\n0.001142\n2958.866089\n601.445928\nPOLYGON ((-7224535.691 2073895.866, -7224528.0...\n\n\n697\n698\nVE\n14\nVIVD09\n742\n-9999\nNP\n1923.031176\n1.294365e-06\n0.005437\nVE\n0.000371\n961.702705\n298.784691\nPOLYGON ((-7224753.339 2073945.558, -7224750.2...\n\n\n645\n646\nVE\n12\nVIVD09\n690\n-9999\nNP\n1356.843890\n3.245918e-07\n0.003876\nVE\n0.001466\n3798.096886\n413.566644\nPOLYGON ((-7224687.595 2073988.764, -7224677.3...\n\n\n700\n701\nVE\n14\nVIVD09\n745\n-9999\nNP\n3733.978623\n3.411003e-06\n0.010518\nVE\n0.001119\n2898.196648\n843.660651\nMULTIPOLYGON (((-7224461.817 2073835.215, -722...\n\n\n698\n699\nVE\n14\nVIVD09\n743\n-9999\nNP\n5286.739577\n8.511948e-06\n0.015016\nVE\n0.000508\n1316.357071\n494.256287\nMULTIPOLYGON (((-7225275.474 2073959.869, -722...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n=== USVI_Tsunami.geojson ===\n{'input_count': 73, 'clipped_count': 1, 'crs': 'EPSG:3857', 'output': 'data\\\\processed\\\\tsunami_st_thomas_3857.gpkg', 'columns': ['FID', 'Id', 'Shape__Area', 'Shape__Length', 'geometry']}\n\n\n\n\n\n\n\n\n\nFID\nId\nShape__Area\nShape__Length\ngeometry\n\n\n\n\n21\n22\n0\n1.082695e+07\n217385.934245\nMULTIPOLYGON (((-7226335.668 2074755.905, -722...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n=== USVI_Ghuts.geojson ===\n{'input_count': 448, 'clipped_count': 115, 'crs': 'EPSG:3857', 'output': 'data\\\\processed\\\\ghuts_st_thomas_3857.gpkg', 'columns': ['FID', 'FNODE_', 'TNODE_', 'LPOLY_', 'RPOLY_', 'LENGTH', 'STREAMS_', 'STREAMS_ID', 'Island', 'Shape__Length', 'geometry']}\n\n\n\n\n\n\n\n\n\nFID\nFNODE_\nTNODE_\nLPOLY_\nRPOLY_\nLENGTH\nSTREAMS_\nSTREAMS_ID\nIsland\nShape__Length\ngeometry\n\n\n\n\n101\n102\n0\n0\n0\n0\n0.0\n0\n0\n\n249.451041\nLINESTRING (-7224823.497 2074305.375, -7224933...\n\n\n99\n100\n0\n0\n0\n0\n0.0\n0\n0\n\n425.691525\nLINESTRING (-7223893.550 2074548.622, -7223888...\n\n\n102\n103\n0\n0\n0\n0\n0.0\n0\n0\n\n269.437508\nLINESTRING (-7225779.508 2074776.958, -7225913...\n\n\n148\n149\n0\n0\n0\n0\n0.0\n0\n0\n\n614.123222\nLINESTRING (-7223042.216 2075060.981, -7223040...\n\n\n105\n106\n0\n0\n0\n0\n0.0\n0\n0\n\n511.166993\nLINESTRING (-7225742.494 2075059.382, -7225772...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n=== LandCover.geojson ===\n{'input_count': 5620, 'clipped_count': 1952, 'crs': 'EPSG:3857', 'output': 'data\\\\processed\\\\landcover_st_thomas_3857.gpkg', 'columns': ['FID', 'OBJECTID', 'class', 'ORIG_FID', 'area', 'SHAPE_Leng', 'Shape__Area', 'Shape__Length', 'geometry']}\n\n\n\n\n\n\n\n\n\nFID\nOBJECTID\nclass\nORIG_FID\narea\nSHAPE_Leng\nShape__Area\nShape__Length\ngeometry\n\n\n\n\n5240\n5241\n5241\nShrub\n12\n0.031451\n92.578198\n281.942528\n87.561300\nPOLYGON ((-7224357.564 2073958.991, -7224357.5...\n\n\n3746\n3747\n3747\nForest\n8\n0.008975\n46.019746\n80.457115\n43.590177\nPOLYGON ((-7224615.736 2073975.853, -7224630.5...\n\n\n5394\n5395\n5395\nWater\n13\n0.012628\n70.897217\n113.198509\n67.288714\nMULTIPOLYGON (((-7224003.406 2074057.871, -722...\n\n\n3748\n3749\n3749\nForest\n8\n0.028330\n74.348617\n253.959190\n70.390788\nPOLYGON ((-7224048.090 2074067.091, -7224069.4...\n\n\n5395\n5396\n5396\nWater\n13\n0.005737\n37.745166\n51.429977\n35.767834\nPOLYGON ((-7223953.476 2074081.683, -7223953.5...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n=== BuildingFootprints.geojson ===\n{'input_count': 44710, 'clipped_count': 16004, 'crs': 'EPSG:3857', 'output': 'data\\\\processed\\\\buildings_st_thomas_3857.gpkg', 'columns': ['FID', 'Class', 'Confidence', 'ORIG_OID', 'STATUS', 'Shape__Area', 'Shape__Length', 'geometry']}\n\n\n\n\n\n\n\n\n\nFID\nClass\nConfidence\nORIG_OID\nSTATUS\nShape__Area\nShape__Length\ngeometry\n\n\n\n\n5247\n5248\n\n0.0\n0\n0\n214.084778\n63.633547\nPOLYGON ((-7222789.340 2074812.204, -7222791.5...\n\n\n5406\n5407\n\n0.0\n0\n0\n270.323380\n73.532001\nPOLYGON ((-7223064.401 2074235.599, -7223079.2...\n\n\n5394\n5395\n\n0.0\n0\n0\n76.485504\n36.766046\nPOLYGON ((-7223145.843 2074313.638, -7223133.2...\n\n\n5389\n5390\n\n0.0\n0\n0\n69.986320\n36.058936\nPOLYGON ((-7223130.951 2074330.540, -7223131.6...\n\n\n5395\n5396\n\n0.0\n0\n0\n140.973251\n49.492848\nPOLYGON ((-7222931.932 2074336.211, -7222920.2...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n=== parcel_value.geojson ===\n{'input_count': 24091, 'clipped_count': 23610, 'crs': 'EPSG:3857', 'output': 'data\\\\processed\\\\parcel_value_st_thomas_3857.gpkg', 'columns': ['DPNR_ZONE', 'PARCEL_NO', 'MAP', 'PARCEL_NAM', 'ACRE', 'LONGITUDE', 'LATITUDE', 'OBJECTID_1', 'PARCEL_NO_', 'Tax_Legal_', 'Name', 'Address', 'City', 'State', 'Zip', 'Country', 'Land_Value', 'Improved_V', 'created_us', 'created_da', 'last_edite', 'last_edi_1', 'SHAPE_Leng', 'SHAPE_Area', 'geometry']}\n\n\n\n\n\n\n\n\n\nDPNR_ZONE\nPARCEL_NO\nMAP\nPARCEL_NAM\nACRE\nLONGITUDE\nLATITUDE\nOBJECTID_1\nPARCEL_NO_\nTax_Legal_\n...\nCountry\nLand_Value\nImproved_V\ncreated_us\ncreated_da\nlast_edite\nlast_edi_1\nSHAPE_Leng\nSHAPE_Area\ngeometry\n\n\n\n\n1673\nR-1\n109701010800\nD9-8000-T007\n8-12\n.90\n-64.845454\n18.311844\n42255\n109701010800\n8-12&8-13 ESTATE NAZARETH 1 RED HOOK\n...\nUnited States\n575500\n102000\nNaN\nNaN\nNaN\nNaN\n327.389648\n3024.317162\nPOLYGON ((-7218569.618 2074067.181, -7218572.8...\n\n\n1672\nR-1\n109701010800\nD9-8000-T007\n8-13\n.72\n-64.845681\n18.312024\n42255\n109701010800\n8-12&8-13 ESTATE NAZARETH 1 RED HOOK\n...\nUnited States\n575500\n102000\nNaN\nNaN\nNaN\nNaN\n236.365302\n2395.937798\nPOLYGON ((-7218623.569 2074080.214, -7218624.7...\n\n\n1482\nR-1\n109701010700\nA9-35-T65\n8-14\nNaN\n-64.845879\n18.312255\n42254\n109701010700\n8-14 ESTATE NAZARETH RED HOOK QTR\n...\nUnited States\n541000\n1200000\nNaN\nNaN\nNaN\nNaN\n192.280658\n1924.277732\nPOLYGON ((-7218589.954 2074123.106, -7218624.7...\n\n\n1480\nR-1\n109701011000\nA3-35-T65\n8-11\nNaN\n-64.845177\n18.312358\n42256\n109701011000\n8-11 ESTATE NAZARETH No.1 RED HOOK QTR.\n...\nUnited States\n399200\n1309700\nNaN\nNaN\nNaN\nNaN\n224.985190\n2455.835935\nPOLYGON ((-7218510.139 2074140.062, -7218512.6...\n\n\n1478\nR-1\n109701010600\nNaN\nNaN\nNaN\n-64.846262\n18.312598\n42253\n109701010600\n8-15 ESTATE NAZARETH RED HOOK QTR\n...\nUnited States\n485700\n695700\nNaN\nNaN\nNaN\nNaN\n230.324864\n1535.526928\nPOLYGON ((-7218626.461 2074150.406, -7218629.8...\n\n\n\n\n5 rows × 25 columns\n\n\n\n\n\n\n\n\n\n\n\nDone. Summary:\nUSVI_Flood_Zone.geojson {'input_count': 2556, 'clipped_count': 499, 'crs': 'EPSG:3857', 'output': 'data\\\\processed\\\\flood_zone_st_thomas_3857.gpkg', 'columns': ['FID', 'FLD_ZONE', 'ST_BFE_ft', 'V_DATUM', 'FZn_ID', 'Depth_ft', 'ZONE_SUBTY', 'SHAPE_Leng', 'Shape__Are', 'Shape__Len', 'FldZone', 'SqMi', 'Shape__Area', 'Shape__Length', 'geometry']}\nUSVI_Tsunami.geojson {'input_count': 73, 'clipped_count': 1, 'crs': 'EPSG:3857', 'output': 'data\\\\processed\\\\tsunami_st_thomas_3857.gpkg', 'columns': ['FID', 'Id', 'Shape__Area', 'Shape__Length', 'geometry']}\nUSVI_Ghuts.geojson {'input_count': 448, 'clipped_count': 115, 'crs': 'EPSG:3857', 'output': 'data\\\\processed\\\\ghuts_st_thomas_3857.gpkg', 'columns': ['FID', 'FNODE_', 'TNODE_', 'LPOLY_', 'RPOLY_', 'LENGTH', 'STREAMS_', 'STREAMS_ID', 'Island', 'Shape__Length', 'geometry']}\nLandCover.geojson {'input_count': 5620, 'clipped_count': 1952, 'crs': 'EPSG:3857', 'output': 'data\\\\processed\\\\landcover_st_thomas_3857.gpkg', 'columns': ['FID', 'OBJECTID', 'class', 'ORIG_FID', 'area', 'SHAPE_Leng', 'Shape__Area', 'Shape__Length', 'geometry']}\nBuildingFootprints.geojson {'input_count': 44710, 'clipped_count': 16004, 'crs': 'EPSG:3857', 'output': 'data\\\\processed\\\\buildings_st_thomas_3857.gpkg', 'columns': ['FID', 'Class', 'Confidence', 'ORIG_OID', 'STATUS', 'Shape__Area', 'Shape__Length', 'geometry']}\nparcel_value.geojson {'input_count': 24091, 'clipped_count': 23610, 'crs': 'EPSG:3857', 'output': 'data\\\\processed\\\\parcel_value_st_thomas_3857.gpkg', 'columns': ['DPNR_ZONE', 'PARCEL_NO', 'MAP', 'PARCEL_NAM', 'ACRE', 'LONGITUDE', 'LATITUDE', 'OBJECTID_1', 'PARCEL_NO_', 'Tax_Legal_', 'Name', 'Address', 'City', 'State', 'Zip', 'Country', 'Land_Value', 'Improved_V', 'created_us', 'created_da', 'last_edite', 'last_edi_1', 'SHAPE_Leng', 'SHAPE_Area', 'geometry']}\n\n\n\nfrom matplotlib import patches as mpatches\n\n# Preview head and plot\nprint(f\"\\n=== {fname} ===\")\nprint(summary[fname])\ndisplay(clipped.head())\n\nfig, ax = plt.subplots(figsize=(8, 10))\n\nboundary.boundary.plot(ax=ax, color=\"black\", linewidth=1, label=\"Boundary\")\nclipped.plot(\n    ax=ax,\n    color=\"#4c72b0\",        \n    alpha=0.6,\n    edgecolor=\"white\",\n    linewidth=0.3,\n    label=f\"{fname} (clipped)\",\n)\n\nax.set_title(f\"{fname} (clipped preview)\")\nax.set_axis_off()\n\nlegend_patches = [\n    mpatches.Patch(facecolor=\"#4c72b0\", edgecolor=\"white\", label=f\"{fname} (clipped)\"),\n    mpatches.Patch(facecolor=\"none\", edgecolor=\"black\", label=\"Boundary\"),\n]\nax.legend(handles=legend_patches, loc=\"lower left\")\n\nplt.tight_layout()\nplt.show()\n\n\n=== parcel_value.geojson ===\n{'input_count': 24091, 'clipped_count': 23610, 'crs': 'EPSG:3857', 'output': 'data\\\\processed\\\\parcel_value_st_thomas_3857.gpkg', 'columns': ['DPNR_ZONE', 'PARCEL_NO', 'MAP', 'PARCEL_NAM', 'ACRE', 'LONGITUDE', 'LATITUDE', 'OBJECTID_1', 'PARCEL_NO_', 'Tax_Legal_', 'Name', 'Address', 'City', 'State', 'Zip', 'Country', 'Land_Value', 'Improved_V', 'created_us', 'created_da', 'last_edite', 'last_edi_1', 'SHAPE_Leng', 'SHAPE_Area', 'geometry']}\n\n\n\n\n\n\n\n\n\nDPNR_ZONE\nPARCEL_NO\nMAP\nPARCEL_NAM\nACRE\nLONGITUDE\nLATITUDE\nOBJECTID_1\nPARCEL_NO_\nTax_Legal_\n...\nCountry\nLand_Value\nImproved_V\ncreated_us\ncreated_da\nlast_edite\nlast_edi_1\nSHAPE_Leng\nSHAPE_Area\ngeometry\n\n\n\n\n1673\nR-1\n109701010800\nD9-8000-T007\n8-12\n.90\n-64.845454\n18.311844\n42255\n109701010800\n8-12&8-13 ESTATE NAZARETH 1 RED HOOK\n...\nUnited States\n575500\n102000\nNaN\nNaN\nNaN\nNaN\n327.389648\n3024.317162\nPOLYGON ((-7218569.618 2074067.181, -7218572.8...\n\n\n1672\nR-1\n109701010800\nD9-8000-T007\n8-13\n.72\n-64.845681\n18.312024\n42255\n109701010800\n8-12&8-13 ESTATE NAZARETH 1 RED HOOK\n...\nUnited States\n575500\n102000\nNaN\nNaN\nNaN\nNaN\n236.365302\n2395.937798\nPOLYGON ((-7218623.569 2074080.214, -7218624.7...\n\n\n1482\nR-1\n109701010700\nA9-35-T65\n8-14\nNaN\n-64.845879\n18.312255\n42254\n109701010700\n8-14 ESTATE NAZARETH RED HOOK QTR\n...\nUnited States\n541000\n1200000\nNaN\nNaN\nNaN\nNaN\n192.280658\n1924.277732\nPOLYGON ((-7218589.954 2074123.106, -7218624.7...\n\n\n1480\nR-1\n109701011000\nA3-35-T65\n8-11\nNaN\n-64.845177\n18.312358\n42256\n109701011000\n8-11 ESTATE NAZARETH No.1 RED HOOK QTR.\n...\nUnited States\n399200\n1309700\nNaN\nNaN\nNaN\nNaN\n224.985190\n2455.835935\nPOLYGON ((-7218510.139 2074140.062, -7218512.6...\n\n\n1478\nR-1\n109701010600\nNaN\nNaN\nNaN\n-64.846262\n18.312598\n42253\n109701010600\n8-15 ESTATE NAZARETH RED HOOK QTR\n...\nUnited States\n485700\n695700\nNaN\nNaN\nNaN\nNaN\n230.324864\n1535.526928\nPOLYGON ((-7218626.461 2074150.406, -7218629.8...\n\n\n\n\n5 rows × 25 columns\n\n\n\n\n\n\n\n\n\n\n\n!pip install rasterio\n\nimport numpy as np\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\nfrom shapely import make_valid\nimport rasterio \nfrom rasterio import merge\nfrom rasterio.mask import mask\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\nfrom rasterio.features import rasterize\nfrom scipy.ndimage import distance_transform_edt\n\nRequirement already satisfied: rasterio in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (1.3.8)\nRequirement already satisfied: affine in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (2.4.0)\nRequirement already satisfied: attrs in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (25.3.0)\nRequirement already satisfied: certifi in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (2025.11.12)\nRequirement already satisfied: click&gt;=4.0 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (8.2.1)\nRequirement already satisfied: cligj&gt;=0.5 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (0.7.2)\nRequirement already satisfied: numpy&gt;=1.18 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (1.24.4)\nRequirement already satisfied: snuggs&gt;=1.4.1 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (1.4.7)\nRequirement already satisfied: click-plugins in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (1.1.1.2)\nRequirement already satisfied: setuptools in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from rasterio) (80.9.0)\nRequirement already satisfied: colorama in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from click&gt;=4.0-&gt;rasterio) (0.4.6)\nRequirement already satisfied: pyparsing&gt;=2.1.6 in d:\\pythonanaconda\\envs\\geospatial\\lib\\site-packages (from snuggs&gt;=1.4.1-&gt;rasterio) (3.0.9)\n\n\n\n# Paths/CRS\ndata_dir = Path(\"data\")\ndem_dir = data_dir / \"USVI-St Thomas dem\"\nprocessed = data_dir / \"processed\"\nprocessed.mkdir(exist_ok=True)\ntarget_crs = \"EPSG:3857\"\n\n# Ghuts (processed vector)\nghuts = gpd.read_file(processed / \"ghuts_st_thomas_3857.gpkg\").to_crs(target_crs)\nghuts[\"geometry\"] = ghuts.geometry.apply(make_valid)\nghuts = ghuts[~ghuts.geometry.is_empty]\n\n\n# Reproject DEM to EPSG:3857\nsrc_dem_path = data_dir / \"USVI_DEM.tif\"\nwith rasterio.open(src_dem_path) as src:\n    dst_transform, dst_width, dst_height = calculate_default_transform(\n        src.crs, target_crs, src.width, src.height, *src.bounds\n    )\n    dst_meta = src.meta.copy()\n    dst_meta.update({\n        \"crs\": target_crs,\n        \"transform\": dst_transform,\n        \"width\": dst_width,\n        \"height\": dst_height,\n        \"nodata\": src.nodata,\n    })\n    dem_reproj_path = processed / \"dem_3857.tif\"\n    with rasterio.open(dem_reproj_path, \"w\", **dst_meta) as dst:\n        for i in range(1, src.count + 1):\n            reproject(\n                source=rasterio.band(src, i),\n                destination=rasterio.band(dst, i),\n                src_transform=src.transform,\n                src_crs=src.crs,\n                dst_transform=dst_transform,\n                dst_crs=target_crs,\n                resampling=Resampling.bilinear,\n            )\nprint(\"Saved reprojected DEM:\", dem_reproj_path)\n\nSaved reprojected DEM: data\\processed\\dem_3857.tif\n\n\n\n# Clip DEM to boundary\nwith rasterio.open(dem_reproj_path) as src:\n    dem_clip, dem_clip_transform = mask(\n        src, [boundary_union], crop=True, all_touched=True, filled=False\n    )\n    dem_clip_meta = src.meta.copy()\n    dem_clip_meta.update({\n        \"height\": dem_clip.shape[1],\n        \"width\": dem_clip.shape[2],\n        \"transform\": dem_clip_transform,\n    })\ndem_clip_path = processed / \"dem_st_thomas_3857.tif\"\nwith rasterio.open(dem_clip_path, \"w\", **dem_clip_meta) as dst:\n    dst.write(dem_clip)\nprint(\"Saved clipped DEM:\", dem_clip_path)\n\nSaved clipped DEM: data\\processed\\dem_st_thomas_3857.tif\n\n\n\nimport numpy as np\n\n# Preview clipped DEM\ndem_data = dem_clip[0]\nfig, ax = plt.subplots(figsize=(8, 6))\n\nleft = dem_clip_transform.c\ntop = dem_clip_transform.f\nright = left + dem_clip.shape[2] * dem_clip_transform.a\nbottom = top + dem_clip.shape[1] * dem_clip_transform.e\n\nimg = ax.imshow(\n    dem_data,\n    extent=(left, right, bottom, top),\n    cmap=\"terrain\",\n    origin=\"upper\"\n)\n\nboundary.boundary.plot(ax=ax, color=\"red\", linewidth=1)\nax.set_title(\"DEM (clipped to St. Thomas)\")\nax.set_axis_off()\nplt.colorbar(img, ax=ax, shrink=0.7)\nplt.show()\n\n\n\n\n\n\n\n\n\n# Slope (degrees)\nwith rasterio.open(dem_clip_path) as src:\n    dem = src.read(1).astype(\"float32\")\n    transform = src.transform\n    nodata = src.nodata\n\npx = transform.a\npy = -transform.e\ndy, dx = np.gradient(dem, py, px)\nslope_rad = np.arctan(np.sqrt(dx**2 + dy**2))\nslope_deg = np.degrees(slope_rad)\n\nif nodata is not None:\n    slope_deg[dem == nodata] = np.nan\n\nslope_meta = dem_clip_meta.copy()\nslope_meta.update({\"dtype\": \"float32\", \"count\": 1, \"nodata\": np.nan})\nslope_path = processed / \"slope_degrees_3857.tif\"\nwith rasterio.open(slope_path, \"w\", **slope_meta) as dst:\n    dst.write(slope_deg.astype(\"float32\"), 1)\nprint(\"Saved slope raster:\", slope_path)\n\nSaved slope raster: data\\processed\\slope_degrees_3857.tif\n\n\n\n# Ghut distance (meters) on DEM grid\nwith rasterio.open(dem_clip_path) as src:\n    out_shape = (src.height, src.width)\n    out_transform = src.transform\n\nghut_mask = rasterize(\n    [(geom, 1) for geom in ghuts.geometry],\n    out_shape=out_shape,\n    transform=out_transform,\n    fill=0,\n    dtype=\"uint8\",\n    all_touched=True,\n)\n\ndist_pixels = distance_transform_edt(ghut_mask == 0)\npixel_size = (abs(out_transform.a) + abs(out_transform.e)) / 2.0\ndist_meters = dist_pixels * pixel_size\n\n# Clamp to 0–1000 m\ndist_meters = np.clip(dist_meters, 0, 1000)\n\n# Classify into 200 m bins (0-200-400-600-800-1000)\n# bins = [0, 200, 400, 600, 800, 1000]\n# dist_binned = np.digitize(dist_meters, bins, right=True)\n\ndist_meta = dem_clip_meta.copy()\ndist_meta.update({\"dtype\": \"float32\", \"count\": 1, \"nodata\": np.nan})\ndist_path = processed / \"ghut_distance_m_3857.tif\"\nwith rasterio.open(dist_path, \"w\", **dist_meta) as dst:\n    dst.write(dist_meters.astype(\"float32\"), 1)\nprint(\"Saved ghut distance raster:\", dist_path)\n\nSaved ghut distance raster: data\\processed\\ghut_distance_m_3857.tif\n\n\n\n# Quick previews\ndef plot_raster(path, title, cmap=\"terrain\", vmin=None, vmax=None):\n    with rasterio.open(path) as src:\n        arr = src.read(1)\n        extent = (src.bounds.left, src.bounds.right, src.bounds.bottom, src.bounds.top)\n    fig, ax = plt.subplots(figsize=(8, 6))\n    img = ax.imshow(arr, extent=extent, origin=\"upper\", cmap=cmap, vmin=vmin, vmax=vmax)\n    boundary.boundary.plot(ax=ax, color=\"red\", linewidth=1)\n    ax.set_title(title)\n    ax.set_axis_off()\n    plt.colorbar(img, ax=ax, shrink=0.7)\n    plt.show()\n\nplot_raster(slope_path, \"Slope (degrees)\", cmap=\"viridis\", vmin=0, vmax=60)\nplot_raster(dist_path, \"Distance to Ghuts (m)\", cmap=\"magma\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport osmnx as ox\nimport geopandas as gpd\nfrom shapely import make_valid\nimport matplotlib.pyplot as plt\n\ntarget_crs = \"EPSG:3857\"\n\n# Boundary to WGS84 for OSM, then project roads back to target CRS\nboundary_wgs_poly = gpd.GeoSeries([boundary_union], crs=boundary.crs).to_crs(4326).iloc[0]\nG = ox.graph_from_polygon(boundary_wgs_poly, network_type=\"drive\")\nG = ox.project_graph(G, to_crs=target_crs)\n\n# Extract edges, fix geometry, clip to boundary\nedges = ox.graph_to_gdfs(G, nodes=False, edges=True)\nedges[\"geometry\"] = edges.geometry.apply(make_valid)\nedges = edges[~edges.geometry.is_empty]\n\nroads_clipped = edges.clip(boundary_union)\nroads_clipped = roads_clipped[~roads_clipped.geometry.is_empty].reset_index(drop=True)\n\n# Keep only a few safe fields; convert object/list/dict to string\nallowed_cols = [\"highway\", \"name\", \"length\", \"oneway\", \"geometry\"]\nroads_clipped = roads_clipped[[c for c in allowed_cols if c in roads_clipped.columns]].copy()\n\nfor col in roads_clipped.columns:\n    if roads_clipped[col].dtype == object:\n        roads_clipped[col] = roads_clipped[col].apply(\n            lambda v: str(v) if isinstance(v, (list, dict)) else v\n        )\n\n# Save\nroads_out = processed / \"roads_st_thomas_3857.gpkg\"\nroads_clipped.to_file(roads_out, driver=\"GPKG\")\n\nprint(f\"\\n=== OSM Roads ===\")\nprint(f\"edges in graph: {len(edges)}, clipped: {len(roads_clipped)}\")\nprint(f\"output: {roads_out}\")\ndisplay(roads_clipped.head())\n\n# Preview\nax = roads_clipped.plot(figsize=(6, 6), linewidth=0.5, color=\"dimgray\")\nboundary.boundary.plot(ax=ax, color=\"red\", linewidth=1)\nax.set_title(\"OSM Roads (clipped)\")\nax.set_axis_off()\nplt.show()\n\n\n=== OSM Roads ===\nedges in graph: 5526, clipped: 5526\noutput: data\\processed\\roads_st_thomas_3857.gpkg\n\n\n\n\n\n\n\n\n\nhighway\nname\nlength\noneway\ngeometry\n\n\n\n\n0\nresidential\nNaN\n1142.816\nFalse\nLINESTRING (-7221794.547 2073225.892, -7221936...\n\n\n1\nresidential\nNaN\n1142.816\nFalse\nLINESTRING (-7222431.840 2073836.435, -7222423...\n\n\n2\ntrunk\nNicholas \"Nick\" Friday Memorial Drive\n762.867\nFalse\nLINESTRING (-7221993.274 2075018.761, -7221986...\n\n\n3\ntrunk\nNicholas \"Nick\" Friday Memorial Drive\n762.867\nFalse\nLINESTRING (-7221590.364 2074955.005, -7221589...\n\n\n4\nresidential\nNadir Hill Road\n476.211\nFalse\nLINESTRING (-7221953.155 2075028.974, -7221933...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom shapely import make_valid\n\n# Load and project\nshelters = gpd.read_file(data_dir / \"Shelter.geojson\").to_crs(target_crs)\nshelters[\"geometry\"] = shelters.geometry.apply(make_valid)\nshelters = shelters[~shelters.geometry.is_empty]\n\n# Clip to boundary (boundary/ boundary_union already in target_crs)\nshelters = gpd.clip(shelters, boundary_union)\nshelters = shelters[~shelters.geometry.is_empty]\n\n# IDs/names\nif \"shelter_id\" not in shelters.columns:\n    shelters[\"shelter_id\"] = shelters.index.astype(str)\nif \"name\" not in shelters.columns:\n    shelters[\"name\"] = shelters.index.astype(str)\n\nprint(\"Shelters after clip:\", shelters.shape)\nshelters.head()\n\nShelters after clip: (6, 8)\n\n\n\n\n\n\n\n\n\nFID\nName\nLatitude\nLongitude\nIsland\ngeometry\nshelter_id\nname\n\n\n\n\n5\n5\nBertha B. Boschulte School\n18.317206\n-64.891119\nSt.Thomas\nPOINT (-7223646.324 2074710.573)\n5\n5\n\n\n0\n0\nSugar Estate Head Start Center\n18.339801\n-64.920562\nSt.Thomas\nPOINT (-7226923.904 2077360.258)\n0\n0\n\n\n1\n1\nCommunity Health Clinic at Schneider\n18.340168\n-64.914869\nSt.Thomas\nPOINT (-7226290.162 2077403.298)\n1\n1\n\n\n4\n4\nCharlotte Amalie High School Auditorium\n18.341186\n-64.919949\nSt.Thomas\nPOINT (-7226855.665 2077522.686)\n4\n4\n\n\n2\n2\nLockhart Elementary\n18.341674\n-64.916455\nSt.Thomas\nPOINT (-7226466.715 2077579.917)\n2\n2\n\n\n\n\n\n\n\n\nimport osmnx as ox\nimport geopandas as gpd\nfrom shapely import make_valid\nimport matplotlib.pyplot as plt\n\ntarget_crs = \"EPSG:3857\"\n\n# 1) Boundary to WGS84 for OSM, then project roads back to target CRS\nboundary_wgs_poly = gpd.GeoSeries([boundary_union], crs=boundary.crs).to_crs(4326).iloc[0]\nG = ox.graph_from_polygon(boundary_wgs_poly, network_type=\"drive\")\nG = ox.project_graph(G, to_crs=target_crs)\n\n# 2) Extract edges, fix geometry, clip to boundary\nedges = ox.graph_to_gdfs(G, nodes=False, edges=True)\nedges[\"geometry\"] = edges.geometry.apply(make_valid)\nedges = edges[~edges.geometry.is_empty]\n\nroads_clipped = edges.clip(boundary_union)\nroads_clipped = roads_clipped[~roads_clipped.geometry.is_empty].reset_index(drop=True)\n\n# 3) Keep only writable fields; convert list/dict to string\nallowed_cols = [\"highway\", \"name\", \"length\", \"oneway\", \"geometry\"]\nroads_clipped = roads_clipped[[c for c in allowed_cols if c in roads_clipped.columns]].copy()\n\nfor col in roads_clipped.columns:\n    if roads_clipped[col].dtype == object:\n        roads_clipped[col] = roads_clipped[col].apply(\n            lambda v: str(v) if isinstance(v, (list, dict)) else v\n        )\n\n# 4) Save\nroads_out = processed / \"roads_st_thomas_3857.gpkg\"\nroads_clipped.to_file(roads_out, driver=\"GPKG\")\n\nprint(f\"\\n=== OSM Roads ===\")\nprint(f\"edges in graph: {len(edges)}, clipped: {len(roads_clipped)}\")\nprint(f\"output: {roads_out}\")\ndisplay(roads_clipped.head())\n\n# 5) Preview\nax = roads_clipped.plot(figsize=(6, 6), linewidth=0.5, color=\"dimgray\")\nboundary.boundary.plot(ax=ax, color=\"red\", linewidth=1)\nax.set_title(\"OSM Roads (clipped)\")\nax.set_axis_off()\nplt.show()\n\n\n=== OSM Roads ===\nedges in graph: 5526, clipped: 5526\noutput: data\\processed\\roads_st_thomas_3857.gpkg\n\n\n\n\n\n\n\n\n\nhighway\nname\nlength\noneway\ngeometry\n\n\n\n\n0\nresidential\nNaN\n1142.816\nFalse\nLINESTRING (-7221794.547 2073225.892, -7221936...\n\n\n1\nresidential\nNaN\n1142.816\nFalse\nLINESTRING (-7222431.840 2073836.435, -7222423...\n\n\n2\ntrunk\nNicholas \"Nick\" Friday Memorial Drive\n762.867\nFalse\nLINESTRING (-7221993.274 2075018.761, -7221986...\n\n\n3\ntrunk\nNicholas \"Nick\" Friday Memorial Drive\n762.867\nFalse\nLINESTRING (-7221590.364 2074955.005, -7221589...\n\n\n4\nresidential\nNadir Hill Road\n476.211\nFalse\nLINESTRING (-7221953.155 2075028.974, -7221933...\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport math\nfrom pathlib import Path\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport geopandas as gpd\nimport rasterio\nfrom shapely import make_valid\n\nimages_dir = Path(\"images\")\nimages_dir.mkdir(exist_ok=True)\n\n# Paths\ndata_dir = Path(\"data\")\nprocessed = data_dir / \"processed\"\ntarget_crs = \"EPSG:3857\"\n\n# Load boundary\nboundary = gpd.read_file(processed / \"st_thomas_boundary.geojson\").to_crs(target_crs)\nboundary_union = boundary.unary_union\n\n# Load and clip shelters\nshelters = gpd.read_file(data_dir / \"Shelter.geojson\").to_crs(target_crs)\nshelters[\"geometry\"] = shelters.geometry.apply(make_valid)\nshelters = shelters[~shelters.geometry.is_empty]\nshelters = gpd.clip(shelters, boundary_union)\nshelters = shelters[~shelters.geometry.is_empty]\nif \"shelter_id\" not in shelters.columns:\n    shelters[\"shelter_id\"] = shelters.index.astype(str)\nif \"name\" not in shelters.columns:\n    shelters[\"name\"] = shelters.index.astype(str)\n\n# Vector layers and titles (including roads)\nvector_layers = [\n    (\"flood_zone_st_thomas_3857.gpkg\",       \"St Thomas_Flood_Zone\"),\n    (\"tsunami_st_thomas_3857.gpkg\",          \"St Thomas_Tsunam_Zone\"),\n    (\"ghuts_st_thomas_3857.gpkg\",            \"St Thomas_Ghuts\"),\n    (\"landcover_st_thomas_3857.gpkg\",        \"St Thomas_LandCover\"),\n    (\"buildings_st_thomas_3857.gpkg\",        \"St Thomas_BuildingFootprints\"),\n    (\"parcel_value_st_thomas_3857.gpkg\",     \"St Thomas_Parcel_Value\"),\n    (\"roads_st_thomas_3857.gpkg\",            \"St Thomas_Road\"),\n]\n\n# Raster layers and titles\nraster_layers = [\n    (processed / \"dem_st_thomas_3857.tif\",          \"St Thomas_DEM\",              \"terrain\", None, None),\n    (processed / \"slope_degrees_3857.tif\",          \"St Thomas_Slope (degrees)\",  \"viridis\", 0, 60),\n    (processed / \"ghut_distance_m_3857.tif\",        \"St Thomas_Distance_to_Ghuts\",\"magma\",   None, None),\n]\n\n# Total plots and layout (+1 for shelters)\nn_plots = len(vector_layers) + len(raster_layers) + 1\nn_cols = 3\nn_rows = math.ceil(n_plots / n_cols)\nfig, axes = plt.subplots(n_rows, n_cols, figsize=(6 * n_cols, 4.5 * n_rows))\naxes = axes.ravel()\n\n# Plot vectors\nfor ax, (fname, title) in zip(axes, vector_layers):\n    gdf = gpd.read_file(processed / fname).to_crs(target_crs)\n    gdf[\"geometry\"] = gdf.geometry.apply(make_valid)\n    gdf = gdf[~gdf.geometry.is_empty]\n    gdf.clip(boundary_union).plot(ax=ax, alpha=0.6, edgecolor=\"k\", linewidth=0.2)\n    boundary.boundary.plot(ax=ax, color=\"red\", linewidth=1)\n    ax.set_title(title, fontsize=11)\n    ax.set_axis_off()\n\n# Plot shelters\nax_idx = len(vector_layers)\nax = axes[ax_idx]\nshelters.plot(ax=ax, color=\"red\", markersize=10, label=\"Shelters\")\nboundary.boundary.plot(ax=ax, color=\"red\", linewidth=1)\nax.set_title(\"St Thomas_Shelter\", fontsize=11)\nax.set_axis_off()\n\n# Plot rasters (DEM uses percentile stretch)\nfor ax, (rpath, title, cmap, vmin, vmax) in zip(axes[ax_idx + 1:], raster_layers):\n    with rasterio.open(rpath) as src:\n        arr = src.read(1).astype(\"float32\")\n        extent = (src.bounds.left, src.bounds.right, src.bounds.bottom, src.bounds.top)\n        nd = src.nodata\n    if nd is not None:\n        arr[arr == nd] = np.nan\n    arr[~np.isfinite(arr)] = np.nan\n\n    # DEM: apply percentile stretch\n    if \"DEM\" in title:\n        vmin = np.nanpercentile(arr, 1)\n        vmax = np.nanpercentile(arr, 99)\n\n    img = ax.imshow(arr, extent=extent, origin=\"upper\", cmap=cmap, vmin=vmin, vmax=vmax)\n    boundary.boundary.plot(ax=ax, color=\"red\", linewidth=1)\n    ax.set_title(title, fontsize=11)\n    ax.set_axis_off()\n    fig.colorbar(img, ax=ax, shrink=0.6)\n\n# Hide any unused axes\nfor ax in axes[n_plots:]:\n    ax.axis(\"off\")\n\nplt.tight_layout()\nout_path = images_dir / \"datasource.png\"\nplt.savefig(out_path, dpi=300, bbox_inches=\"tight\")\nprint(f\"Saved plot to {out_path}\")\n\nSaved plot to images\\datasource.png"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Bertilsson, L., Wiklund, K., de Moura Tebaldi, I., Rezende, O. M., Veról, A. P., & Miguez, M. G. (2019). Urban flood resilience – A multi-criteria index to integrate flood resilience into urban planning. Journal of Hydrology, 573, 970–982. https://doi.org/10.1016/j.jhydrol.2018.06.052\nHumanity Road. (2017). Hurricane Irma: Situation report 2 (TC-2017-000125-DOM) [PDF]. https://reliefweb.int/report/dominican-republic/hurricane-irma-situation-report-2-7-september-2017\nHu, S., Cheng, X., Zhou, D., & others. (2017). GIS-based flood risk assessment in suburban areas: A case study of the Fangshan District, Beijing. Natural Hazards, 87, 1525–1543. https://doi.org/10.1007/s11069-017-2828-0\nNkeki, F. N., Bello, E. I., & Agbaje, I. G. (2022). Flood risk mapping and urban infrastructural susceptibility assessment using a GIS and analytic hierarchical raster fusion approach in the Ona River Basin, Nigeria. International Journal of Disaster Risk Reduction, 77, 103097.\nNOAA National Centers for Coastal Ocean Science. (n.d.). Assessing community risk in relation to flood hazard in the U.S. Virgin Islands. https://coastalscience.noaa.gov/project/assessing-community-risk-in-relation-to-flood-hazard-in-the-u-s-virgin-islands/\nNOAA National Centers for Coastal Ocean Science. (2024, December 17). Community vulnerability assessment to flood hazard in the U.S. Virgin Islands. https://coastalscience.noaa.gov (Primary contact: chloe.fleming@noaa.gov )\nQin, X., Wang, S., Meng, M., Long, H., Zhang, H., & Shi, H. (2025). Enhancing urban resilience through machine learning-supported flood risk assessment: Integrating flood susceptibility with building function vulnerability. npj Urban Sustainability, 5(1), 19.\nSeydi, S. T., Kanani-Sadat, Y., Hasanlou, M., Sahraei, R., Chanussot, J., & Amani, M. (2022). Comparison of machine learning algorithms for flood susceptibility mapping. Remote Sensing, 15(1), 192.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "stthomas.html",
    "href": "stthomas.html",
    "title": "Flood Risk in St Thomas",
    "section": "",
    "text": "St. Thomas, one of the major islands of the U.S. Virgin Islands, lies in the eastern Caribbean, where steep volcanic terrain meets a shallow, highly dynamic coastal shelf. Steep topography and coastal concentration of development make small island cities highly sensitive to flooding, and St. Thomas is no exception.\n\n\nCode\nimport folium\nimport geopandas as gpd\n\n# Load boundary in WGS84\nboundary = gpd.read_file(\"data/processed/st_thomas_boundary.geojson\").to_crs(\"EPSG:4326\")\n\n# Project to a planar CRS (UTM zone 20N) to compute centroid accurately\nboundary_proj = boundary.to_crs(epsg=32620)\nctr_proj = boundary_proj.geometry.centroid\n\n# Transform centroid back to WGS84 for map center\nctr_wgs = gpd.GeoSeries(ctr_proj, crs=32620).to_crs(epsg=4326)\ncenter_lat = ctr_wgs.y.mean()\ncenter_lon = ctr_wgs.x.mean()\n\n# Build the Folium map\nf = folium.Figure(height=500)\nm = folium.Map(location=[center_lat, center_lon], zoom_start=12, control_scale=True).add_to(f)\n\n# Esri Satellite basemap\nfolium.TileLayer(\n    tiles='https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n    attr='Esri',\n    name='Esri Satellite',\n    overlay=False,\n    control=True\n).add_to(m)\n\n# Boundary overlay\nfolium.GeoJson(\n    boundary.to_json(),\n    name=\"Boundary\",\n    style_function=lambda x: {\"color\": \"#DD6F78\", \"weight\": 2, \"fill\": False},\n).add_to(m)\n\n# Layer control\nfolium.LayerControl().add_to(m)\n\n# Display in notebook\nm\n\n\n\n  \n  \n  \n    Figure 1: St Thomas, USVI\n  \n\nFlooding has long been a persistent and destructive force across St. Thomas’s residential neighborhoods. Seasonal storms and intense rainfall frequently overwhelm the island’s limited drainage capacity, resulting in rapid water accumulation across hillside settlements and low-lying coastal communities. The scale of past impacts underscores the severity of this hazard: there is a 92% chance of flooding during 4 inches or more of rainfall, 85% of households reported damage during the 2017 hurricanes, and estimated economic losses exceeded $11.25 billion. These recurring disruptions highlight the intertwined roles of environmental exposure, infrastructure limitations, and socioeconomic fragility.\n\n\n\n\n\nFigure 2: Homes Damaged by Hurricane Irma in St Thomas\n\n\n\n\n\n\nFigure 3: Flood Hazard in St Thomas\n\n\n\nIn this project, community-level flood risk in St. Thomas is assessed using a Python and machine-learning framework that integrates flood susceptibility with community explosure. By mapping the spatial pattern of flood risk, identifying key environmental drivers, and comparing exposure disparities, such as shelter accessibility and variations in land value, the analysis provides essential insights for understanding flood exposure, locating safe shelters, and planning appropriate insurance coverage.",
    "crumbs": [
      "Flood Risk in St Thomas"
    ]
  },
  {
    "objectID": "stthomas.html#st-thomas",
    "href": "stthomas.html#st-thomas",
    "title": "Flood Risk in St Thomas",
    "section": "",
    "text": "St. Thomas, one of the major islands of the U.S. Virgin Islands, lies in the eastern Caribbean, where steep volcanic terrain meets a shallow, highly dynamic coastal shelf. Steep topography and coastal concentration of development make small island cities highly sensitive to flooding, and St. Thomas is no exception.\n\n\nCode\nimport folium\nimport geopandas as gpd\n\n# Load boundary in WGS84\nboundary = gpd.read_file(\"data/processed/st_thomas_boundary.geojson\").to_crs(\"EPSG:4326\")\n\n# Project to a planar CRS (UTM zone 20N) to compute centroid accurately\nboundary_proj = boundary.to_crs(epsg=32620)\nctr_proj = boundary_proj.geometry.centroid\n\n# Transform centroid back to WGS84 for map center\nctr_wgs = gpd.GeoSeries(ctr_proj, crs=32620).to_crs(epsg=4326)\ncenter_lat = ctr_wgs.y.mean()\ncenter_lon = ctr_wgs.x.mean()\n\n# Build the Folium map\nf = folium.Figure(height=500)\nm = folium.Map(location=[center_lat, center_lon], zoom_start=12, control_scale=True).add_to(f)\n\n# Esri Satellite basemap\nfolium.TileLayer(\n    tiles='https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n    attr='Esri',\n    name='Esri Satellite',\n    overlay=False,\n    control=True\n).add_to(m)\n\n# Boundary overlay\nfolium.GeoJson(\n    boundary.to_json(),\n    name=\"Boundary\",\n    style_function=lambda x: {\"color\": \"#DD6F78\", \"weight\": 2, \"fill\": False},\n).add_to(m)\n\n# Layer control\nfolium.LayerControl().add_to(m)\n\n# Display in notebook\nm\n\n\n\n  \n  \n  \n    Figure 1: St Thomas, USVI\n  \n\nFlooding has long been a persistent and destructive force across St. Thomas’s residential neighborhoods. Seasonal storms and intense rainfall frequently overwhelm the island’s limited drainage capacity, resulting in rapid water accumulation across hillside settlements and low-lying coastal communities. The scale of past impacts underscores the severity of this hazard: there is a 92% chance of flooding during 4 inches or more of rainfall, 85% of households reported damage during the 2017 hurricanes, and estimated economic losses exceeded $11.25 billion. These recurring disruptions highlight the intertwined roles of environmental exposure, infrastructure limitations, and socioeconomic fragility.\n\n\n\n\n\nFigure 2: Homes Damaged by Hurricane Irma in St Thomas\n\n\n\n\n\n\nFigure 3: Flood Hazard in St Thomas\n\n\n\nIn this project, community-level flood risk in St. Thomas is assessed using a Python and machine-learning framework that integrates flood susceptibility with community explosure. By mapping the spatial pattern of flood risk, identifying key environmental drivers, and comparing exposure disparities, such as shelter accessibility and variations in land value, the analysis provides essential insights for understanding flood exposure, locating safe shelters, and planning appropriate insurance coverage.",
    "crumbs": [
      "Flood Risk in St Thomas"
    ]
  },
  {
    "objectID": "stthomas.html#data-sources",
    "href": "stthomas.html#data-sources",
    "title": "Flood Risk in St Thomas",
    "section": "Data Sources",
    "text": "Data Sources\nThis project uses the following datasets, all clipped to the administrative boundary of St. Thomas, USVI. Foundational spatial datasets, including historical flood zones, tsunami hazard zones, land cover, ghut (drainage channel) networks, designated emergency shelters, and administrative boundaries, were obtained from the USVI Open Data Portal (https://usvi-open-data-portal-upenn.hub.arcgis.com/ ). These layers provide essential contextual information on flooding hazards, drainage infrastructure, and critical facilities. Building footprint and parcel data, provided by the local government, contain housing and land value information used to identify residential buildings and analyze form and density in Python.Road networks data were derived using Pandana’s OpenStreetMap interface in Python.\nThe Digital Elevation Model (DEM) used in this study was sourced from the USGS 3D Elevation Program (https://usgs.entwine.io/ ) and provides approximately 10-meter spatial resolution, suitable for representing the steep terrain of St. Thomas. From this DEM, two terrain indicators were derived. First, slope was calculated using Python (numpy and rasterio) by computing pixel-level elevation gradients, resulting in a continuous slope raster capturing areas prone to rapid runoff. Second, distance to ghuts was generated by rasterizing drainage channels and applying Euclidean distance transforms, producing a 0–1000 m proximity raster that represents hydrologic pathways. These DEM-based derivatives form key environmental predictors for modeling flood susceptibility across the island.\n\n\nCode\n!pip install osmnx\n\nimport osmnx as ox\nimport geopandas as gpd\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nimport math\nfrom pathlib import Path\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport geopandas as gpd\nimport rasterio\nfrom shapely import make_valid\n\nimages_dir = Path(\"images\")\nimages_dir.mkdir(exist_ok=True)\n\n# Paths\ndata_dir = Path(\"data\")\nprocessed = data_dir / \"processed\"\ntarget_crs = \"EPSG:3857\"\n\n# Load boundary\nboundary = gpd.read_file(processed / \"st_thomas_boundary.geojson\").to_crs(target_crs)\nboundary_union = boundary.unary_union\n\n# Load and clip shelters\nshelters = gpd.read_file(data_dir / \"Shelter.geojson\").to_crs(target_crs)\nshelters[\"geometry\"] = shelters.geometry.apply(make_valid)\nshelters = shelters[~shelters.geometry.is_empty]\nshelters = gpd.clip(shelters, boundary_union)\nshelters = shelters[~shelters.geometry.is_empty]\nif \"shelter_id\" not in shelters.columns:\n    shelters[\"shelter_id\"] = shelters.index.astype(str)\nif \"name\" not in shelters.columns:\n    shelters[\"name\"] = shelters.index.astype(str)\n\n# Vector layers and titles (including roads)\nvector_layers = [\n    (\"flood_zone_st_thomas_3857.gpkg\",       \"St Thomas_Flood_Zone\"),\n    (\"tsunami_st_thomas_3857.gpkg\",          \"St Thomas_Tsunam_Zone\"),\n    (\"ghuts_st_thomas_3857.gpkg\",            \"St Thomas_Ghuts\"),\n    (\"landcover_st_thomas_3857.gpkg\",        \"St Thomas_LandCover\"),\n    (\"buildings_st_thomas_3857.gpkg\",        \"St Thomas_BuildingFootprints\"),\n    (\"parcel_value_st_thomas_3857.gpkg\",     \"St Thomas_Parcel_Value\"),\n    (\"roads_st_thomas_3857.gpkg\",            \"St Thomas_Road\"),\n]\n\n# Raster layers and titles\nraster_layers = [\n    (processed / \"dem_st_thomas_3857.tif\",          \"St Thomas_DEM\",              \"terrain\", None, None),\n    (processed / \"slope_degrees_3857.tif\",          \"St Thomas_Slope (degrees)\",  \"viridis\", 0, 60),\n    (processed / \"ghut_distance_m_3857.tif\",        \"St Thomas_Distance_to_Ghuts\",\"magma\",   None, None),\n]\n\n# Total plots and layout (+1 for shelters)\nn_plots = len(vector_layers) + len(raster_layers) + 1\nn_cols = 3\nn_rows = math.ceil(n_plots / n_cols)\nfig, axes = plt.subplots(n_rows, n_cols, figsize=(6 * n_cols, 4.5 * n_rows))\naxes = axes.ravel()\n\n# Plot vectors\nfor ax, (fname, title) in zip(axes, vector_layers):\n    gdf = gpd.read_file(processed / fname).to_crs(target_crs)\n    gdf[\"geometry\"] = gdf.geometry.apply(make_valid)\n    gdf = gdf[~gdf.geometry.is_empty]\n    gdf.clip(boundary_union).plot(ax=ax, alpha=0.6, edgecolor=\"k\", linewidth=0.2)\n    boundary.boundary.plot(ax=ax, color=\"red\", linewidth=1)\n    ax.set_title(title, fontsize=11)\n    ax.set_axis_off()\n\n# Plot shelters\nax_idx = len(vector_layers)\nax = axes[ax_idx]\nshelters.plot(ax=ax, color=\"red\", markersize=10, label=\"Shelters\")\nboundary.boundary.plot(ax=ax, color=\"red\", linewidth=1)\nax.set_title(\"St Thomas_Shelter\", fontsize=11)\nax.set_axis_off()\n\n# Plot rasters (DEM uses percentile stretch)\nfor ax, (rpath, title, cmap, vmin, vmax) in zip(axes[ax_idx + 1:], raster_layers):\n    with rasterio.open(rpath) as src:\n        arr = src.read(1).astype(\"float32\")\n        extent = (src.bounds.left, src.bounds.right, src.bounds.bottom, src.bounds.top)\n        nd = src.nodata\n    if nd is not None:\n        arr[arr == nd] = np.nan\n    arr[~np.isfinite(arr)] = np.nan\n\n    # DEM: apply percentile stretch\n    if \"DEM\" in title:\n        vmin = np.nanpercentile(arr, 1)\n        vmax = np.nanpercentile(arr, 99)\n\n    img = ax.imshow(arr, extent=extent, origin=\"upper\", cmap=cmap, vmin=vmin, vmax=vmax)\n    boundary.boundary.plot(ax=ax, color=\"red\", linewidth=1)\n    ax.set_title(title, fontsize=11)\n    ax.set_axis_off()\n    fig.colorbar(img, ax=ax, shrink=0.6)\n\n# Hide any unused axes\nfor ax in axes[n_plots:]:\n    ax.axis(\"off\")\n\nplt.show()\n\n\n\n\n\nFigure 4: Data Source",
    "crumbs": [
      "Flood Risk in St Thomas"
    ]
  },
  {
    "objectID": "stthomas.html#what-this-project-plans-to-do",
    "href": "stthomas.html#what-this-project-plans-to-do",
    "title": "Flood Risk in St Thomas",
    "section": "What This Project Plans to Do?",
    "text": "What This Project Plans to Do?\nBelow is the workflow diagram for this project, accompanied by a concise summary of the major steps:\nFirst, a flood inventory is generated by sampling flooded and non-flooded points across St. Thomas and attaching key environmental predictors such as elevation, slope, distance to ghuts, tsunami exposure, and land cover. These data form the basis for training the flood-susceptibility model.\nNext, the dataset is split into training and testing sets, and a Random Forest classifier is applied to estimate flood susceptibility across the island. The model outputs a continuous surface of predicted flood likelihood, supporting community-level risk awareness and hazard communication.\nThe workflow then evaluates safety protection by assessing shelter accessibility. Using road-network data and shelter locations, walkable paths are modeled to calculate the nearest distance to designated shelters, highlighting disparities in evacuation potential.\nFinally, parcel-value information is integrated with flood susceptibility and shelter access to assess risk management needs. This combined analysis identifies communities facing compound vulnerabilities and informs the development of community flood-risk maps and exposure-disparity assessments.\n Note: This section summarizes the workflow; technical procedures and Python implementation details are provided in the Methods and Analysis section. \n\n\n\nFigure 5: Step-wise framework",
    "crumbs": [
      "Flood Risk in St Thomas"
    ]
  }
]